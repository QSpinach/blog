[{"title":"mac使用问题汇总","date":"2020-10-19T03:01:56.307Z","path":"2020/10/19/mac使用问题汇总/","text":"mac使用问题汇总如何安装nginx安装homebrew，使用brew安装nginx查看是否安装nginx 1brew search nginx 安装ginx 1brew install nginx nginx安装路径/usr/local/etc/nginx/启动nginx，默认访问8080端口 1nginx 关闭nginx 1nginx -s stop 如何安装homebrew国内安装 1/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; 官方安装 1$ /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot; 也可以加速克隆 123BREW_REPO=&quot;https://github.com/Homebrew/brew&quot;# 变成：BREW_REPO=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git&quot; 其他镜像安装 1234567891011121314# brew 程序本身，Homebrew/Linuxbrew 相同git -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git# 以下针对 mac OS 系统上的 Homebrewgit -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.gitgit -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.gitgit -C &quot;$(brew --repo homebrew/cask-fonts)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-fonts.gitgit -C &quot;$(brew --repo homebrew/cask-drivers)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-drivers.git# 以下针对 Linux 系统上的 Linuxbrewgit -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/linuxbrew-core.git# 更换后测试工作是否正常brew update 恢复 1234567891011121314# brew 程序本身，Homebrew/Linuxbrew 相同git -C &quot;$(brew --repo)&quot; remote set-url origin https://github.com/Homebrew/brew.git# 以下针对 mac OS 系统上的 Homebrewgit -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://github.com/Homebrew/homebrew-core.gitgit -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://github.com/Homebrew/homebrew-cask.gitgit -C &quot;$(brew --repo homebrew/cask-fonts)&quot; remote set-url origin https://github.com/Homebrew/homebrew-cask-fonts.gitgit -C &quot;$(brew --repo homebrew/cask-drivers)&quot; remote set-url origin https://github.com/Homebrew/homebrew-cask-drivers.git# 以下针对 Linux 系统上的 Linuxbrewgit -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://github.com/Homebrew/linuxbrew-core.git# 更换后测试工作是否正常brew update 如何展示隐藏文件及文件夹123# 关闭显示隐藏文件的话就把上面的命令中YES改为NO就行了defaults write com.apple.Finder AppleShowAllFiles YESkillall Finder 安装 webstorm 2020.3.21234567891011121314151617181920# 删除配置信息目录rm -rf ~/Library/Preferences/WebStorm*# 删除插件信息目录rm -rf ~/Library/Application\\ Support/WebStorm*# 缓存信息目录rm -rf ~/Library/Caches/WebStorm*# 删除日志信息目录rm -rf ~/Library/Logs/WebStorm*# 删除Webstorm.vmoptionscd /Users/leitianxiao/Library/Application\\ Support//JetBrains/Webstorm2020.2/Webstorm.vmoptionsrm -f Webstorm.vmoptions","tags":[{"name":"MAC","slug":"MAC","permalink":"https://qspinach.github.io/blog/tags/MAC/"}]},{"title":"搭建vue项目","date":"2020-08-23T15:45:11.821Z","path":"2020/08/23/搭建vue项目/","text":"搭建VUE项目概要本文档用于总结VUE项目的搭建及使用，基于不同的UI搭建原理其实是一样的。以Vant为例简单概述从项目创建到打包部署过程中需要注意的内容。 推荐UI​ 移动端：vant-ui、cube-ui ​ PC端：element-ui、iView 环境 nvm(node版本管理工具) npm || yarn （包管理工具，高版本nodejs可能需要手动安装npm） nodejs（运行环境） 开始创建项目以vant-ui为例子搭建，使用 Vue 官方提供的脚手架 Vue Cli 3 创建项目 1234567891011121314# 安装 Vue Clinpm install -g @vue/cli# 创建一个项目vue create hello-world# 创建完成后，可以通过命令打开图形化界面，如下图所示vue ui# 通过 npm 安装npm i vant -S# 通过 yarn 安装yarn add vant 文件目录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182│ .env.development│ .env.production│ .env.sit│ .env.uat│ .eslintrc.js│ .gitignore│ babel.config.js│ Dockerfile│ nginx.conf│ package-lock.json│ package.json│ README.md│ vue.config.js│ yarn.lock│ ├─public│ │ favicon.ico│ │ index.html│ │ │ └─svg│ loading-spin.svg│ └─src │ App.vue │ error.js │ main.js │ permission.js │ vant-ui.js │ ├─api │ index.js │ login.js │ user.js │ ├─assets │ back.png │ login.jpg │ logo.png │ ├─components │ └─404 │ index.vue │ ├─configs │ apiURL.js │ errorCode.js │ index.js │ ├─routers │ │ index.js │ │ │ └─modules │ default.js │ ├─stores │ │ getters.js │ │ index.js │ │ │ └─modules │ permission.js │ user.js │ ├─styles │ transition.css │ ├─utils │ auth.js │ index.js │ request.js │ validate.js │ └─views │ ├─home │ Home.vue │ Home2.vue │ ├─login │ Login.vue │ └─test Test.vue 添加适配方案Rem 适配Vant 中的样式默认使用px作为单位，如果需要使用rem单位，推荐使用以下两个工具： postcss-pxtorem 是一款 postcss 插件，用于将单位转化为 rem lib-flexible 用于设置 rem 基准值 在vue.config.js中配置即可完成适配 12345678910111213css: &#123; loaderOptions: &#123; postcss: &#123; plugins: [ autoprefixer(), pxtorem(&#123; rootValue: 37.5, propList: ['*'] &#125;) ] &#125; &#125; &#125;, 开发代理方便开发对接接口及方便管理使用代理，生产可使用nginx做代理 123456789101112131415161718192021devServer: &#123; // 设置主机地址 // host: 'localhost', // 设置默认端口 port: 8000, // 设置代理 disableHostCheck: true, proxy: &#123; '/v2': &#123; // 目标 API 地址 target: 'http://rap2api.taobao.org', // 如果要代理 websockets ws: true, // 将主机标头的原点更改为目标URL // changeOrigin: true, pathRewrite: &#123; '^/v2': '/app/mock' //代理的路径 &#125; &#125; &#125; &#125;, 优化引用三方库使用webpack-bundle-analyzer可以查看各部分打包后的大小，如果太大需要做特殊引用。 在index.html中引用三方库 12&lt;script src=\"//shadow.elemecdn.com/npm/vue@2.6.10/dist/vue.runtime&lt;%= process.env.NODE_ENV === 'production' ? '.min.js' : '.js' %&gt;\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"//shadow.elemecdn.com/npm/vue-router@3.0.3/dist/vue-router&lt;%= process.env.NODE_ENV === 'production' ? '.min.js' : '.js' %&gt;\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; 在vue.config.js中配置三方库 1234567891011configureWebpack: &#123; plugins: [ new BundleAnalyzerPlugin() // 其他 plugins ... ], externals: &#123; vue: \"window.Vue\", \"vue-router\": \"window.VueRouter\" // 其他三方库 ... &#125; &#125; 静态变量及环境变量根据不同的启动命令获取不同的环境变量值，在package.json中配置运行命令执行不同命令会使用不同文件下定义的变量。例如：.env.development、.env.production、.env.sit、.env.uat文件中，默认yarn dev使用development，yarn build使用production，还可以自己添加sit和uat。 123456\"scripts\": &#123; \"dev\": \"npm run serve\", \"build\": \"vue-cli-service build\", \"sit\": \"vue-cli-service build --mode sit\", \"uat\": \"vue-cli-service build --mode uat\" &#125;, 在.env.development中 123NODE_ENV='development'VUE_APP_CURRENTMODE='development'VUE_APP_BASEURL='http://127.0.0.1:8001' 在.env.production中 123NODE_ENV='production'VUE_APP_CURRENTMODE='production'VUE_APP_BASEURL='http://127.0.0.1:8002' 在代码中的使用变量 1const baseUrl = process.env.VUE_APP_BASEURL 静态变量定义在指定文件中，使用时即可引用。 123456789101112131415/** * 配置静态变量 */// 路由白名单const whiteList = [ '/login', // 登录 '/404']const baseUrl = process.env.VUE_APP_BASEURLconst imgUrl = baseUrl // 图片服务器地址export &#123; whiteList, imgUrl&#125; 工具文件 自定义request.js封装axios作为调用接口工具。 12345678910111213141516171819202122232425262728293031// 返回其他状态吗service.defaults.validateStatus = function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt;= 500&#125;// 处理请求头axios.interceptors.request.use(config =&gt; &#123; const isToken = (config.headers || &#123;&#125;).isToken === false let token = store.getters.access_token // 可以根据vuex或者storage获取 if (token &amp;&amp; !isToken) &#123; config.headers['Authorization'] = 'Bearer ' + token // token &#125; return config&#125;, error =&gt; &#123; return Promise.reject(error)&#125;)// 处理返回信息axios.interceptors.response.use(res =&gt; &#123; const status = Number(res.status) || 200 const message = res.data.error_description || errorCode[status] || errorCode['default'] if (status === 401) &#123; // TODO 登出 return &#125; if (!(status === 200 || status === 204)) &#123; // TODO 提示错误信息 return Promise.reject(new Error(message)) &#125; return res&#125;, error =&gt; &#123; return Promise.reject(new Error(error))&#125;) 在调用接口时候即可使用request工具 123456789101112import request from '@/utils/request'import &#123; apiUrl &#125; from '@/configs/apiURL'const login = apiUrl.loginconst LoginByMobile = (data) =&gt; &#123; return request(&#123; url: login.doLogin, method: 'POST', type: 'json', data, &#125;)&#125; 如果想为了方便管理接口地址，可以将接口地址统一管理 12345678910111213141516171819const baseUrl = \"/v1\" // 代理地址const baseUrlMock = \"/v2\" // mock地址const apiUrlFn = (baseUrl) =&gt; &#123; return &#123; login: &#123; doLogin: baseUrl + \"/app/login\", // 登录 doLogout: baseUrl + \"/app/logout\" // 登出 &#125;, user: &#123; getUserInfo: baseUrlMock + \"/app/userinfo\" &#125; &#125;&#125;const apiUrl = apiUrlFn(baseUrl);export &#123; baseUrl, baseUrlMock, apiUrl&#125; 根据不同状态码提示不同的信息，可以做一个errorCode静态变量对象 1234export default &#123; '401': '当前操作没有权限', 'default': '系统未知错误,请反馈给管理员'&#125; 自定义validate.js作为数据校验工具 12345678910/* 大小写字母*/export function validateAlphabets(str) &#123; const reg = /^[A-Za-z]+$/ return reg.test(str)&#125;/* 小写字母*/export function validateLowerCase(str) &#123; const reg = /^[a-z]+$/ return reg.test(str)&#125; 自定义auth.js作为存储登录token工具（可以用cookie，sessionStorage，localStorage） 123456789101112131415import Cookies from 'js-cookie'const TokenKey = 'Token'export function getToken() &#123; return Cookies.get(TokenKey) // return sessionStorage.getItem(TokenKey)&#125;export function setToken(token) &#123; // return Cookies.set(TokenKey, token, &#123;expires: 0.001&#125;) // 过期时间一分多钟 return Cookies.set(TokenKey, token, &#123;expires: 7&#125;) // 过期时间7天 // return sessionStorage.setItem(TokenKey, token)&#125;export function removeToken() &#123; return Cookies.remove(TokenKey) // return sessionStorage.removeItem(TokenKey)&#125; 自定义其他一些好用的数据处理工具 12345678/** * 获取地址栏参数 */export function getUrlParam(name) &#123; var reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\"); //构造一个含有目标参数的正则表达式对象 var r = window.location.search.substr(1).match(reg); //匹配目标参数 if (r != null) return unescape(r[2]); return null; //返回参数值&#125; 登录与微信登录登录需用到vuex和storage以便存储和获取登录用户信息 在store中定义user 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748state: &#123; user: '', name: '', token: getToken(), roles: [], &#125;,actions: &#123; LoginByMobile(&#123;commit&#125;, userinfo)&#123; return new Promise((resolve, reject) =&gt; &#123; login.LoginByMobile(userinfo).then(response =&gt; &#123; const &#123; code, msg, token &#125; = response.data if (code != 0) &#123; // TODO 提示登录失败 reject(\"登录失败\") return; &#125; commit('SET_TOKEN', token) commit('SET_NAME', \"\") setToken(token) resolve(response) &#125;).catch(error =&gt; &#123; reject(error) &#125;) &#125;) &#125;,&#125;,// 获取用户信息 GetUserInfo(&#123; commit, state &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(); userApi.getInfo() .then(res =&gt; res.data) .then(res =&gt; &#123; const &#123; result, msg, code &#125; = res; if (code == 0) &#123; commit('SET_NAME', result.name) commit('SET_ID', result.id) commit('SET_ROLES', result.roles) resolve(res); &#125; else &#123; reject('error') &#125; &#125;) .catch(error =&gt; &#123; reject('error') &#125;) &#125;) &#125;, 在页面定义登录点击事件调用LoginByMobile即可。登录后获取token存入vuex和storage，再获取用户信息存入vuex。 如果是手机端微信登录需要使用openid（微信用户与公众号之间的唯一标识）登录。这里需用到微信的jssdk配合后台接口获取openid。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061if (getToken()) &#123; // 验证是否含有token /* has token*/ if (to.path === '/login') &#123; next(&#123; path: '/' &#125;) NProgress.done() &#125; else &#123; if (store.getters.roles.length === 0) &#123; // 判断当前用户是否已拉取完user_info信息 store.dispatch('GetUserInfo').then(res =&gt; &#123; // 拉取user_info const roles = res.result.roles // ['user','admin'] store.dispatch('GenerateRoutes', &#123; roles &#125;).then(() =&gt; &#123; // 根据roles权限生成可访问的路由表 router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表 next(&#123; ...to, replace: true &#125;) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record &#125;) &#125;).catch((err) =&gt; &#123; store.dispatch('FedLogOut').then(() =&gt; &#123; next(&#123; path: '/' &#125;) &#125;) &#125;) &#125; else &#123; next() &#125; &#125;&#125; else &#123; const code = getUrlParam('code') const openid = sessionStorage.getItem('openid') if (code &amp;&amp; !openid) &#123; // 获取openid login.getUserOpenId(&#123; code: code &#125;) .then(res =&gt; res.data) .then(res =&gt; &#123; if (res.code == 0) &#123; sessionStorage.setItem('openid', res.openId) if (res.token) &#123; store.dispatch('LoginSetToken', &#123;token: res.token&#125;).then(() =&gt; &#123; // 拉取user_info setToken(res.token) next() &#125;) &#125; else &#123; next(`/login`) // 否则全部重定向到登录页 NProgress.done() &#125; &#125; &#125;).catch(err =&gt; &#123; console.log(err) &#125;) &#125; else &#123; if (!openid) &#123; window.location.href = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=$&#123;AppId&#125;&amp;redirect_uri=http%3a%2f%2xx.xxx.com&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirect` &#125; else &#123; /* has no token*/ if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入 next() &#125; else &#123; next(`/login`) // 否则全部重定向到登录页 NProgress.done() &#125; &#125; &#125;&#125; 权限路由权限做路由权限有两种，一种是动态路由，一种是静态路由。动态路由信息完全由后台数据库存储，通过接口去获取数据。静态路由则完全由前端控制，可通过不同角色去过滤路由。 静态路由 1234567891011121314/* router.js */const RouterDefault = [ &#123; path: '/', name: 'home1', component: () =&gt; import('@/views/home/Home.vue'), // 普通用户 meta: &#123; title: '首页', keepAlive: true, noCache: false, roles: [\"user\"] &#125;, &#125;, &#123; path: '/', name: 'other', component: () =&gt; import('@/views/a_otherRoles/leader/home/index.vue'), // 其他用户 meta: &#123; title: '首页', keepAlive: true, noCache: false, roles: [\"other\"] &#125;, &#125; &#125; 过滤函数 12345678910111213141516171819/** * 递归过滤异步路由表，返回符合用户角色权限的路由表 * @param routes asyncRouterMap * @param roles */function filterAsyncRouter(routes, roles) &#123; const res = [] routes.forEach(route =&gt; &#123; const tmp = &#123; ...route &#125; if (hasPermission(roles, tmp)) &#123; if (tmp.children) &#123; tmp.children = filterAsyncRouter(tmp.children, roles) &#125; res.push(tmp) &#125; &#125;) return res&#125; 过滤路由并添加到vuex中 12345678910111213GenerateRoutes(&#123; commit &#125;, data) &#123; return new Promise(resolve =&gt; &#123; const &#123; roles &#125; = data let accessedRouters if (roles.includes('admin')) &#123; accessedRouters = asyncRouterMap &#125; else &#123; accessedRouters = filterAsyncRouter(asyncRouterMap, roles) &#125; commit('SET_ROUTERS', accessedRouters) resolve() &#125;) &#125; 如果是通过接口获取的路由信息则可以直接拼接静态路由和动态路由信息，当然获取路由信息需要在登录之后或者刷新页面的时候。 123456789101112export default new Router(&#123; mode: 'history', base: process.env.BASE_URL, scrollBehavior: () =&gt; (&#123; y: 0 &#125;), routes: constantRouterMap&#125;)export const asyncRouterMap = [ ...RouterDefault, &#123; path: '*', redirect: '/404', hidden: true &#125;] 按钮权限按钮权限可以根据角色在前端判断是否展示；也可以在数据库中存储按钮信息，在按钮上绑定的接口权限，通过接口返回按钮信息，前端判断是否展示。 可以自定义定义指令实现按钮展示 12345678910111213141516171819202122232425262728293031323334353637// 检查是否包含按钮function permissionCheck(code) &#123; const permissionList = store.getters.permissions const stringCode = code.split('||') const menuCode = stringCode[0] const buttonCode = stringCode[1] let checkFlag = false permissionList.some((item, index) =&gt; &#123; if (item.menuCode == menuCode) &#123; if(!!item.permitAll) &#123; checkFlag = true &#125; else &#123; item.roleButtons.some((itemBtn, indexBtn) =&gt; &#123; if (itemBtn.buttonCode == buttonCode) &#123; checkFlag = true return true &#125; &#125;) &#125; return true &#125; &#125;) return checkFlag&#125;/** * @export 自定义指令 */export function directive() &#123; Vue.directive('permit', &#123; bind(el, binding) &#123; if(!permissionCheck(binding.value)) &#123; el.parentNode &amp;&amp; el.parentNode.removeChild(el) &#125; &#125; &#125;)&#125; 在vue代码中可以使用v-permit 12345678&lt;el-button class=&quot;filter-item&quot; v-permit=&quot;&apos;ROLE-SETTING||role_create&apos;&quot; @click=&quot;handleCreate&quot; size=&quot;small&quot; type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt; 添加&lt;/el-button&gt; 问题 vue缓存页面使用 在路由文件中添加meta 123456&#123; path: 'newslist', name: 'NewsList', meta: &#123;keepAlive: true&#125;, component: () =&gt; import('@/pages/NewsList')&#125; 在router-view处添加 1234&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; 这样页面就只会加载一次然后缓存起来，再次访问不回刷新数据。 如果需要在另一个页面跳转过来刷新数据时，则需要使用beforeRouteLeave 关键是设置keepAlive 123456beforeRouteLeave(to, from, next) &#123; // 设置下一个路由meta to.meta.keepAlive = false; // 让页面不缓存，重新请求数据 console.log(to); next(); // 跳转页面&#125; 页面刷新vuex被清空 同一页面，刷新后vuex被清空 试用localstorage存储 重新获取数据 需要某些数据之前先判断一下数据是否存在，如果不存在重新获取。 nextTick适当使用 延迟到下次dom更新循环之后执行延迟回调，在修改数据之后立即执行这个方法，获取最新的DOM。获取更新后的DOM言外之意就是什么操作需要用到了更新后的DOM而不能使用之前的DOM或者使用更新前的DOM或出问题，所以就衍生出了这个获取更新后的DOM的Vue方法。所以放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码. 你在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。 原因：在执行created时并没有dom渲染，此时进行dom操作无效，将执行dom操作的js代码放入nextTick回调函数中，与其相对应的是mounted钩子函数。 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。 原因：vue是异步执行dom更新，一旦观察到数据变化，vue会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。 简而言之，等待DOM更新之后再进行操作。 组件之间的调用方式 父子组件 prop向下传递，事件向上传递 子组件添加ref属性，父组件可以获取到子组件的实例，不推荐使用 插槽slot 作用域插槽 非父子组件 使用状态管理 实例化一个公共vue实例 必须要有公共的实例（可以是空的），才能使用 $emit 获取 $on 的数据参数，实现组件通信 计算属性设置值 计算属性是基于它们的依赖进行缓存的，一旦依赖发生变化，计算属性会重新计算 通过set方法触发它所依赖的变量，单纯的赋值，在取值的时候不会被改变 vue文件中内联样式中有无scoped属性的差别 有scoped只在当前vue文件中可以使用这个样式 无scoped，会影响其他文件 v-for v-key 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 v-for v-if 当它们处于同一节点，v-for的优先级比v-if更高。 组件、prop大小写不敏感，事件敏感 不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。 不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或属性名，所以就没有理由使用 camelCase 或 PascalCase 了。 prop值的改变–不是立即 如果父组件中给子组件传递了一个prop的值，然后调用子组件的方法去获取该值，会发现值没有立即改变。 可以监听值的改变去调用相应子组件的方法 将子组件相关方法的调用放在nextTick里面 对象中某属性值的监听 普通的watch中只能监听到某对象的变化才会调用，当想监听对象以及对象中属性的变化都调用函数时，可以使用deep:true 12345678910111213141516data() &#123; return &#123; bet: &#123; pokerState: 53, pokerHistory: 'local' &#125; &#125;&#125;,watch: &#123; bet: &#123; handler(newValue, oldValue) &#123; console.log(newValue) &#125;, deep: true &#125;&#125; this.$forceUpdate 强制刷新页面，触发页面重新渲染 vue中的beforeRouteUpdate 在xxx/detail/123和xxx/edit/123都用了同一个组件，beforeRouteUpdate不生效，但是watch $route是生效的？ 扩展： 可以考虑在路由定义处使用别名 alias 官方解释 123456beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, 简单部署 执行命令前端代码打包，生成dist打包后的文件 1yarn build 将打包后的文件放至指定目录 配置nginx文件 1234567891011121314server &#123; listen 80; listen [::]:80; server_name localhost; location / &#123; root /var/www/html; index index.html index.htm; try_files $uri $uri/ /index.html; &#125; location /v2 &#123; proxy_set_header Host rap2api.taobao.org; proxy_pass http://rap2api.taobao.org; &#125;&#125; 重启nginx Docker部署项目打包部署步骤 编写Dockerfile 123456FROM docker-registry.xxx/docker/nginx:1.13.6COPY ./dist /var/www/htmlCOPY ./nginx.conf /etc/nginx/conf.d/ RUN rm /etc/nginx/conf.d/default.confEXPOSE 80CMD [\"nginx\",\"-g\",\"daemon off;\"] 打包镜像 1docker build -t 镜像名 . 启动容器 1docker run -it --name 容器名 -p 80:80 镜像||id docker安装123456789101112131415$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2$ sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo$ sudo yum makecache fast$ sudo yum -y install docker-ce$ sudo systemctl start docker 查看日志12345docker logs -f -t --since=“2017-05-31” --tail=10 容器–since : 此参数指定了输出日志开始日期，即只输出指定日期之后的日志。-f : 查看实时日志-t : 查看日志产生的日期-tail=10 : 查看最后的10条日志。 几个命令1234567891011docker start/stop/restart 容器id #启动暂停重启docker rm 容器id #删除docker kill 容器id #杀掉一个运行中的容器。docker pause/unpause 容器id #暂停/取消暂停docker create 镜像 // 创建容器但是不运行docker exec -i -t 容器 /bin/bash #开启一个交互模式的终端docker rmi &lt;image id&gt; # 移除镜像docker rmi $(docker images | grep \"none\" | awk '&#123;print $3&#125;') #移除为none的镜像docker rm $(docker ps -a | grep \"Exited\" | awk '&#123;print $1 &#125;') #移除为exited的容器docker images -a 查看镜像docker ps -a 查看容器","tags":[{"name":"Vue","slug":"Vue","permalink":"https://qspinach.github.io/blog/tags/Vue/"}]},{"title":"总结","date":"2020-08-23T15:45:11.821Z","path":"2020/08/23/总结/","text":"阿里respositoryhttps://maven.aliyun.com/repository/spring jar包安装到本地仓库mvn install:install-file -Dfile=D:\\commons-logging-1.2.jar -DgroupId=org.apache.commons -DartifactId=commons-logging -Dversion=1.2 -Dpackaging=jar resetful（1）每一个URI代表一种资源；（2）客户端和服务器之间，传递这种资源的某种表现层；（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 Axure注册License：zdfans.comKey：gP5uuK2gH+iIVO3YFZwoKyxAdHpXRGNnZWN8Obntqv7++FF3pAz7dTu8B61ySxli webstorm 激活http://idea.iteblog.com/key.php idea激活http://idea.imsxm.com/http://intellij.mandroid.cn/http://idea.iteblog.com/key.php nginx./nginx #打开 nginxnginx -s reload|reopen|stop|quit #重新加载配置|重启|停止|退出 nginxnginx -t #测试配置是否有语法错误 启动Android模拟器cd c:&#39;Program Files’\\android\\toolsemulator.exe -netdelay none -netspeed full -avd Pixel_API_25 win10 电脑 Ubuntu路径C:\\Users\\syq\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\rootfs 查看文件夹被哪个应用使用 任务管理器 》 性能 》资源监视器 》CPU 》关联的句柄 》结束进程网页中的视频播放1&lt;embed id=&quot;movie_player&quot; name=&quot;movie_player&quot; width=&quot;300&quot; height=&quot;180&quot; pluginspage=&quot;http://www.macromedia.com/go/getflashplayer&quot; flashvars=&quot;VideoIDS=XNDA5NTEwMTA0&amp;isAutoPlay=true&amp;isShowRelatedVideo=false&quot; allowfullscreen=&quot;true&quot; quality=&quot;high&quot; bgcolor=&quot;#FFFFFF&quot; src=&quot;http://static.youku.com/v1.0.0098/v/swf/qplayer.swf&quot; type=&quot;application/x-shockwave-flash&quot;&gt; 在网页中不能复制内容，在body标签中加1onmousemove=&quot;HideMenu()&quot; oncontextmenu=&quot;return false&quot; ondragstart=&quot;return false&quot; onselectstart =&quot;return false&quot; onselect=&quot;document.selection.empty()&quot; oncopy=&quot;document.selection.empty()&quot; onbeforecopy=&quot;return false&quot; onmouseup=&quot;document.selection.empty() 自定义右键菜单HKEY_CLASSES_ROOT\\Directory\\background\\shell windows 电脑查询端口1netstat -ano react-router目前用的是3.X版本，4.X版本不适用3.X MongoDB启动：mongod –dbpath D:\\nodejs\\mongodb使用：1、mongo2、show dbs3、use 名字4、查询 db.users.find(); npm 更新package.json1、npm install -g npm-check-updates *** npm-check-updates ncu -a2、npm install -g npm-check npm-check -u mysql更改root密码 停止mysql数据库/etc/init.d/mysqld stop 执行如下命令mysqld_safe –user=mysql –skip-grant-tables –skip-networking &amp; 使用root登录mysql数据库mysql -u root mysql 更新root密码mysql&gt; UPDATE user SET Password=PASSWORD(‘newpassword’) where USER=’root’; 最新版MySQL请采用如下SQL：mysql&gt; UPDATE user SET authentication_string=PASSWORD(‘newpassword’) where USER=’root’; 刷新权限mysql&gt; FLUSH PRIVILEGES; 退出mysqlmysql&gt; quit 重启mysql/etc/init.d/mysqld restart 使用root用户重新登录mysqlmysql -uroot -pEnter password: &lt;输入新设的密码newpassword&gt; VSCODE插件——- 12345678BeautifyESLintGitLens-Git superchargedLive ServerPower ModeVeturvscode-iconsVue 2 Snippets 配置——- 123456789101112131415161718192021222324252627282930313233&#123; &quot;editor.tabSize&quot;: 2, &quot;javascript.implicitProjectConfig.experimentalDecorators&quot;: true, &quot;liveServer.settings.donotShowInfoMsg&quot;: true, &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;, &quot;powermode.enabled&quot;: true, // &quot;powermode.presets&quot;: &quot;fireworks&quot;, &quot;powermode.presets&quot;: &quot;flames&quot;, &quot;powermode.enableShake&quot;: false, &quot;workbench.colorCustomizations&quot;: &#123; &quot;editorWhitespace.foreground&quot;: &quot;#FFFFFF00&quot; &#125;, &quot;window.zoomLevel&quot;: 0, &quot;extensions.ignoreRecommendations&quot;: true, &quot;emmet.syntaxProfiles&quot;: &#123; &quot;vue-html&quot;: &quot;html&quot;, &quot;vue&quot;: &quot;html&quot; &#125;, &quot;vetur.validation.template&quot;: false, &quot;eslint.options&quot;: &#123; &quot;plugins&quot;: [&quot;html&quot;] &#125;, &quot;eslint.validate&quot;: [ &quot;javascript&quot;, &quot;javascriptreact&quot;, &quot;html&quot;, &quot;vue&quot; ], &quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;, &quot;vetur.format.defaultFormatterOptions&quot;: &#123; &quot;wrap_attributes&quot;: &quot;force-aligned&quot; &#125;&#125; 谷歌浏览器模拟 user agent支付宝Mozilla/5.0…AlipayDefined(nt:WIFI,ws:320|504|2.0) AliApp(AP/9.6.0.000001) AlipayClient/9.6.0.000001 Language/zh-Hans ProductType/dev 安卓微信UA： mozilla/5.0 (linux; u; android 4.1.2; zh-cn; mi-one plus build/jzo54k) applewebkit/534.30 (khtml, like gecko) version/4.0 mobile safari/534.30 micromessenger/5.0.1.352 Ios微信UA： mozilla/5.0 (iphone; cpu iphone os 5_1_1 like mac os x) applewebkit/534.46 (khtml, like gecko) mobile/9b206 micromessenger/5.0 12","tags":[{"name":"other","slug":"other","permalink":"https://qspinach.github.io/blog/tags/other/"}]},{"title":"函数总结","date":"2020-08-23T15:45:11.820Z","path":"2020/08/23/函数总结/","text":"/秒杀倒计时/12345678910111213141516171819202122232425262728293031var secondKill = function()&#123; /*复盒子*/ var parentTime = document.getElementsByClassName(&apos;sk_time&apos;)[0]; /*span时间*/ var timeList = parentTime.getElementsByClassName(&apos;num&apos;); console.log(timeList.length); var times = 7 * 60 * 60; var timer; timer = setInterval(function()&#123; times -- ; var h = Math.floor(times/(60*60)); var m = Math.floor(times/60%60); var s = times%60; console.log(h+&apos;-&apos;+m+&quot;-&quot;+s); timeList[0].innerHTML = h&gt;10?Math.floor(h/10):0; timeList[1].innerHTML = h%10; timeList[2].innerHTML = m&gt;10?Math.floor(m/10):0; timeList[3].innerHTML = m%10; timeList[4].innerHTML = s&gt;10?Math.floor(s/10):0; timeList[5].innerHTML = s%10; if(times &lt;= 0)&#123; clearInterval(timer); &#125; &#125;,1000);","tags":[{"name":"js","slug":"js","permalink":"https://qspinach.github.io/blog/tags/js/"}]},{"title":"webpack","date":"2020-08-23T15:45:11.820Z","path":"2020/08/23/webpack/","text":"Webpack安装本地安装 12npm install --save-dev webpacknpm install --save-dev webpack@&lt;version&gt; 全局安装 1npm install --gobal webpack 基本使用123456789const path = require('path');module.exports = &#123; entry: './src/index.js', // 入口文件 output: &#123; // 出口文件 filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;; 资源管理 css加载，需安装css-loader和style-loader并在module配置 1npm install --save-dev style-loader css-loader 1234567891011121314151617181920const path = require('path'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] &#125; ] &#125; &#125;; less加载，需安装less-loader并在module配置,安装less-loader时需要安装less 1npm install --save-dev less-loader less 123456789101112module: &#123; rules: [ &#123; test: /\\.less/, use: [ 'style-loader', 'css-loader', 'less-loader' ] &#125; ] &#125; sass加载，需安装sass-loader并在module配置,安装sass-loader时需要安装node-sass node-sass需要在淘宝镜像源下安装 1npm install --save-dev sass-loader node-sass 123456789101112module: &#123; rules: [ &#123; test: /\\.scss/, use: [ 'style-loader', 'css-loader', 'sass-loader' ] &#125; ] &#125; 图片路径，需安装配置url-loader 1npm install --save-dev url-loader 1234567891011121314module: &#123; rules: [ &#123; test: /\\.(png|svg|jpg|gif)$/, use: [&#123; loader: 'url-loader', options: &#123; limit: 2048, name: '[hash:8]-[name].[ext]' &#125; &#125;] &#125; ]&#125; 图片加载，需安装配置file-loader 1npm install --save-dev file-loader 12345678910module: &#123; rules: [ &#123; test: /\\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ] &#125; ]&#125; 字体加载同样需要安装配置file-loader 12345678910module: &#123; rules: [ &#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ] &#125; ]&#125; 加载数据,如 JSON 文件，CSV、TSV 和 XML。使用csv-loader和xml-loader安装配置即可处理CSV、TSV 和 XML类型的文件。 1npm install --save-dev csv-loader xml-loader 12345678910111213141516module: &#123; rules: [ &#123; test: /\\.(csv|tsv)$/, use: [ 'csv-loader' ] &#125;, &#123; test: /\\.xml$/, use: [ 'xml-loader' ] &#125; ]&#125; HtmlWebpackPlugin 创建了一个全新的文件，所有的 bundle 会自动添加到 html 中。 1234567891011121314151617181920const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/index.js', print: './src/print.js' &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname, './src/index.html'), filename: 'index.html', title: 'Output Management' &#125;) ], output: &#123; filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; HtmlWebpackPlugin 在每次构建前清理 /dist 文件夹 1234567891011121314151617181920const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/index.js', print: './src/print.js' &#125;, plugins: [ new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin(&#123; title: 'Output Management' &#125;) ], output: &#123; filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; 为了更容易跟踪错误和警告JavaScript 提供了 source map 功能。 123module.exports = &#123; devtool: 'inline-source-map',&#125; webpack-dev-server 提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)。 123456// webpack.jsmodule.exports = &#123; devServer: &#123; contentBase: './dist' &#125;,&#125; 1234// package.json\"scripts\": &#123; \"server\": \"webpack-dev-server --open\"&#125; 模块热替换是webpack内置的功能，无需进行完全刷新。 12345678910// webpack.jsmodule.exports = &#123; devServer: &#123; contentBase: './dist', hot: true &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125; tree shaking移除 JavaScript 上下文中的未引用代码(dead-code)。从 webpack 4 开始，也可以通过 &quot;mode&quot; 配置选项轻松切换到压缩输出，只需设置为 &quot;production&quot;。 123module.exports = &#123; mode: \"production\"&#125; 要让代码支持es6及更高语法需要以下步骤 123456/** 1、安装第一套包 npm install babel-core babel-loader babel-plugin-transform-runtime --dev-save 2、安装第二套包 npm install babel-preset-env babel-preset-stage-0 --save-dev 3、webpack配置文件添加新的匹配规则 &#123;test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/&#125; 4、根目录下新建.babelrc的Babel配置文件 &#123;\"presets\": [\"env\", \"stage-0\"], \"plugins\": [\"transform-runtime\"]&#125;**/ 修改包文件的入口和出口文件 1234567891011resolve: &#123; // 自动补全的扩展名 extensions: ['.js', '.vue', '.json'], // 默认路径代理 // 例如 import Vue from 'vue'，会自动到 'vue/dist/vue.common.js'中寻找 alias: &#123; // 别名 '@': path.resolve('src'), '@config': path.resolve('config'), 'vue$': 'vue/dist/vue.common.js' &#125;&#125; 生产环境问题WARNING in asset size limit: The following asset(s) exceed the recommended size limit (244 KiB).解决 在webpack中配置 123performance: &#123; hints:false&#125; webpack中如何使用vue 安装vue包 安装解析vue文件的vue-loader vue-template-complier 在入口文件main.js中导入vue模块 定义vue组件，组件组成部分template，script，style 导入定义好的组件 创建vue实例 new Vue({ el: ‘#app’, render: c =&gt; c(login) }) 在页面中创建一个id为app的div元素，作为我们vue实例控制区域 vue中引入mui.min.js报错，解决办法在.babel中加入 1\"ignore\":[ './src/assets/js/mui.js']","tags":[{"name":"webpack","slug":"webpack","permalink":"https://qspinach.github.io/blog/tags/webpack/"}]},{"title":"影视笔记","date":"2020-08-23T15:45:11.820Z","path":"2020/08/23/影视笔记/","text":"视图：alt + 左键 旋转 alt + 右键 缩放 alt + 中间 移动空格键 四视图 顶视|透视 ———————————— 前视|侧视空格+鼠标左键top view 顶视 front view 前视 rigth view 侧视 perspective view 透视左边菜单 快捷键W移动 E旋转 R缩放 G重复上一步 T显示弯曲控制器变形规则：点 线 面选择点中物体鼠标右键 Vertex 点， Face 面， Edge 边， Object Mode 退出点和面挤压选中物体面 shift+鼠标右键向下划 Extrude Face岛角 岛边shift+鼠标右键 Bevel Edge polyBevel1 offset 0.5 偏移值 segments 2 次数弯曲变形Deformation 横向段数变化数必须够删除历史记录：快捷键是 alt+shift+D显示所有界面Display &gt;&gt; UI Elements &gt;&gt; Show All UI Elements删线shift+鼠标右键 Delete Edge坐标轴居中Modify &gt;&gt; Center Pivot零面的观察方法及解决方法观察：右击物体 Vertex Face 点面模式 解决方法：选中零面所在的点 执行shift+鼠标右键向上划 Merge Vertices合并点 &gt;&gt; Merge Vertices maya导入图片菜单栏 快速创建物体shift+鼠标右键 创建多边形工具 | 圆柱—————球体分割多边形shift+鼠标右键 Split 右击结束绘制 W结束命令操作 调整中心点D键 + 鼠标左键 移动坐标轴 V键 + 鼠标左键 吸附点 同时按下D键和V键镜像复制 关联复制1、Edit &gt;&gt; Duplicate Special 口 [属性框] 2、Scale： X Y Z 3、Apply合并物体和分离物体shift+鼠标右键 向下 Combine合并 Separate分离为什么选这张素材？设计制作的思路？运用到哪些知识点？制作过程中遇到哪些问题？实训阶段感悟？","tags":[{"name":"影视笔记","slug":"影视笔记","permalink":"https://qspinach.github.io/blog/tags/%E5%BD%B1%E8%A7%86%E7%AC%94%E8%AE%B0/"}]},{"title":"vue总结","date":"2020-08-23T15:45:11.820Z","path":"2020/08/23/vue总结/","text":"问题1、vue缓存页面使用在路由文件中添加meta 123456&#123; path: 'newslist', name: 'NewsList', meta: &#123;keepAlive: true&#125;, component: () =&gt; import('@/pages/NewsList')&#125; 在router-view处添加 1234&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; 这样页面就只会加载一次然后缓存起来，再次访问不回刷新数据。 如果需要在另一个页面跳转过来刷新数据时，则需要使用beforeRouteLeave 关键是设置keepAlive 123456beforeRouteLeave(to, from, next) &#123; // 设置下一个路由meta to.meta.keepAlive = false; // 让页面不缓存，重新请求数据 console.log(to); next(); // 跳转页面&#125; 2、页面刷新vuex被清空同一页面，刷新后vuex被清空 试用localstorage存储 重新获取数据 需要某些数据之前先判断一下数据是否存在，如果不存在重新获取。 3、nextTick适当使用 延迟到下次dom更新循环之后执行延迟回调，在修改数据之后立即执行这个方法，获取最新的DOM。获取更新后的DOM言外之意就是什么操作需要用到了更新后的DOM而不能使用之前的DOM或者使用更新前的DOM或出问题，所以就衍生出了这个获取更新后的DOM的Vue方法。所以放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码. 你在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。 原因：在执行created时并没有dom渲染，此时进行dom操作无效，将执行dom操作的js代码放入nextTick回调函数中，与其相对应的是mounted钩子函数。 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。 原因：vue是异步执行dom更新，一旦观察到数据变化，vue会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。 简而言之，等待DOM更新之后再进行操作。 4、组件之间的调用方式父子组件 prop向下传递，事件向上传递 子组件添加ref属性，父组件可以获取到子组件的实例，不推荐使用 插槽slot 作用域插槽 非父子组件 使用状态管理 实例化一个公共vue实例 必须要有公共的实例（可以是空的），才能使用 $emit 获取 $on 的数据参数，实现组件通信 5、计算属性设置值 计算属性是基于它们的依赖进行缓存的，一旦依赖发生变化，计算属性会重新计算 通过set方法触发它所依赖的变量，单纯的赋值，在取值的时候不会被改变 6、vue文件中内联样式中有无scoped属性的差别 有scoped只在当前vue文件中可以使用这个样式 无scoped，会影响其他文件 7、v-for v-key为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 8、v-for v-if当它们处于同一节点，v-for的优先级比v-if更高。 9、组件、prop大小写不敏感，事件敏感不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。 不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或属性名，所以就没有理由使用 camelCase 或 PascalCase 了。 10、prop值的改变–不是立即如果父组件中给子组件传递了一个prop的值，然后调用子组件的方法去获取该值，会发现值没有立即改变。 可以监听值的改变去调用相应子组件的方法 将子组件相关方法的调用放在nextTick里面 11、对象中某属性值的监听普通的watch中只能监听到某对象的变化才会调用，当想监听对象以及对象中属性的变化都调用函数时，可以使用deep:true 12345678910111213141516data() &#123; return &#123; bet: &#123; pokerState: 53, pokerHistory: 'local' &#125; &#125;&#125;,watch: &#123; bet: &#123; handler(newValue, oldValue) &#123; console.log(newValue) &#125;, deep: true &#125;&#125; 12、this.$forceUpdate强制刷新页面，触发页面重新渲染 13、vue中的beforeRouteUpdate在xxx/detail/123和xxx/edit/123都用了同一个组件，beforeRouteUpdate不生效，但是watch $route是生效的？ 扩展： 可以考虑在路由定义处使用别名 alias 官方解释 123456beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;,","tags":[{"name":"Vue","slug":"Vue","permalink":"https://qspinach.github.io/blog/tags/Vue/"}]},{"title":"Hexo","date":"2020-08-23T15:45:11.793Z","path":"2020/08/23/hexo/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://qspinach.github.io/blog/tags/Hexo/"}]},{"title":"nginx","date":"2020-08-23T15:45:11.793Z","path":"2020/08/23/nginx/","text":"nginx配置前端打包后的代码———————————-server { listen 8000; server_name localhost; location / { root html/vue-anchor-admin; index index.html index.htm; } location /api { proxy_set_header Host wx.guanxiaohe.cn; proxy_pass http://wx.guanxiaohe.cn/ssm; }} server { listen 8002; server_name localhost; location / { root html/vue-anchor-admin-iview; index index.html index.htm; try_files $uri $uri/ /index.html; } location /api { proxy_set_header Host rap2api.taobao.org; proxy_pass http://rap2api.taobao.org/app/mock/122795; }} nginx查看访问量最高的ip地址1awk '&#123;print $1&#125;' /var/log/nginx/access.log | sort | uniq -c | sort -nr -k1 | head -n 10 nginx 配置多个文件1include vhost/*.conf;","tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://qspinach.github.io/blog/tags/Nginx/"}]},{"title":"js总结","date":"2020-08-23T15:45:11.793Z","path":"2020/08/23/js总结/","text":"reduce 问题在ie下会出现Uint8Array 无法使用reduce方法，原因ie下Uint8Array不是一个数组集合而是一个对象集合解决方法：使用lodash中的reduce，即可兼容Array|Object ============================================================== 获取json对象的键和值var data = {a: 1, b: 2, c: 3, d: 4}Object.keys(data); // [“a”, “b”, “c”, “d”]Object.values(data); // [1, 2, 3, 4] ============================================================== vscode 修饰报错 修改setting“javascript.implicitProjectConfig.experimentalDecorators”: true ============================================================== 状态栏window对象的defaultStatus状态栏显示时间d = new Date();time = d.getHours();window.status = time; 盗链问题1234567891011121314var frontURL = document.referrer;var host = location.hostname;if(frontURL != &quot;&quot;)&#123; var frontHost = frontURL.substring(7.host.length + 7) if(host == frontHost)&#123; alert(&quot;没有盗链&quot;); &#125; else&#123; alert(&quot;非法盗链&quot;); &#125;&#125;else&#123; alert(&quot;你是直接打开文档的&quot;);&#125; 锚对象window.document.anchors 历史对象history.go(n)n=0表示载入当前页面，n&gt;0表示载入历史列表中往前数第n个页面,n&lt;0表示载入历史列表中的往后数第n个页面 华氏温度和摄氏温度1234var degFahren = prompt(&quot;Enter the degrees in Fahrenheit&quot;,50);var degCent;degCent = 5/9*(degFahren-32);alert(degCent); 数据类型转换1234567parseInt();parseFloat();for...in循环,无需知道数组的元素的个数var elementIndex;for(elementIndex in myArray)&#123; document.write(myArray[elementIndex]);&#125; 阶乘1calcFactorial(num); 在一个字符串中查找另一个字符串1indexOf(); 复制字符串的一个子串12var myString = &quot;JavaScript&quot;;var mySubString = myString.substring(0,4); 转换大小写1toLowerCase()和toUpperCase() 将字符编码转换为字符串 fromCharCode()方法1var myString = String.fromCharCode(65,66,67); slice()方法，复制数组的部分12var names = new Array(&quot;Eggs&quot;,&quot;Milks&quot;,&quot;Potatoes&quot;);var slicedArray = names.slice(1,3); join()将数组转换为字符串12var myShopping = new Array(&quot;Eggs&quot;,&quot;Milks&quot;,&quot;Potatoes&quot;);var myShooingList = myShopping.join(&quot;&lt;br/&gt;&quot;); 按字母排序12var names = new Array(&quot;Eggs&quot;,&quot;Milks&quot;,&quot;Potatoes&quot;);names.sort(); reverse()方法，反转数组元素的顺序12var myShopping = new Array(&quot;Eggs&quot;,&quot;Milks&quot;,&quot;Potatoes&quot;);myShopping.reverse(); 测试元素1234every();some();filter();var num = new Array(1,2,3);function Test()&#123;&#125;every(Test); abs();返回所传入的绝对值12var myNumber = -101;document.write(Math.abs(myNumber)); ceil();修整到最接近的最小整数，即向上修整floor();舍去小数部分round();大于等于0.5向上修整，小于等于0.5向下修整 正则表达式“g”表示全局标志 ***select改变值事件 1select.onchange = function()&#123;&#125;; *添加删除数组 push()后面推进去 向数组的末尾添加一个或多个元素，并返回新的长度。 unshift()从数组的前面放入 向数组的开头添加一个或更多元素，并返回新的长度 pop() 删除最后一个数组元素 shift()删除第一个数组元素*数组和字符串转换 join()将数组转换为字符串 split()将字符串转换为数组*插入子节点 1. appendChild(); 添加孩子 append 添加的意思 意思： 添加孩子 放到盒子的 最后面。 2. insertBefore(插入的节点，参照节点) 子节点 添加孩子*克隆节点 cloneNode(); 括号里面可以跟参数 ， 如果 里面是 true 深层复制， 除了复制本盒子，还复制子节点 如果为 false 浅层复制 只复制 本节点 不复制 子节点。 **url编码和解码 encodeURIComponent()函数可把字符串作为URI组件进行编码 decodeURIComponent()函数可把字符串作为URI组件进行解码**substr() substr(起始位置,[取的个数]) 同上。 不写取的个数， 默认从起始位置一直取到最后 。 取的个数： 是指从起始位置开始，往后面数几个。 ***offset家族 offsetWidth offsetHeight 得到对象的宽度和高度(自己的，与他人无关) offsetWidth = width + border + padding offsetLeft offsetTop 返回距离上级盒子（最近的带有定位）左边的位置 **offsetTop var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;**client clientX clientWidth 可视区域的宽度 clientWidth width + padding offsetWidth width + padding + border scrollWidth width + padding 超过 内容的宽度**Math Math.ceil(); 向上取整 Math.floor();向下取整 Math.round();四舍五入**获取css样式 1. obj.currentStyle ie opera 常用 外部（使用）和内嵌（使用）样式表中的样式（ie和opera） 2 .window.getComputedStyle(“元素”, “伪类”) w3c 两个选项是必须的， 没有伪类 用 null 替代 3.兼容 function getStyle(obj,attr) { if (obj.currentStyle) { return obj.currentStyle[attr]; } else { return window.getComputedStyle(obj,null)[attr]; } }***in运算符 in运算符也是一个二元运算符，但是对运算符左右两个操作数的要求比较严格。 in运算符要求第1个（左边的）操作数必须是字符串类型或可以转换为字符串类型的其他类型， 而第2个（右边的）操作数必须是数组或对象。只有第1个操作数的值是第2个操作数的属性名， 才会返回true，否则返回false js 内置对象：12345678910111213String DateMathArrayRegExpNumberObjectFunctionNullBooleanErrorCookieSession Js Bom对象123456WindowDocumentHistoryLocationScreenNavigator 将伪数组转化为数组12var json = &#123;0:&apos;first&apos;,1:&apos;second&apos;,length:2&#125;;Array.prototype.slice.call(json); 写一个通用的事件侦听器函数// event(事件)工具集，来源：github.com/markyun 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576markyun.Event = &#123; // 页面加载完成后 readyEvent : function(fn) &#123; if (fn==null) &#123; fn=document; &#125; var oldonload = window.onload; if (typeof window.onload != &apos;function&apos;) &#123; window.onload = fn; &#125; else &#123; window.onload = function() &#123; oldonload(); fn(); &#125;; &#125; &#125;, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(&apos;on&apos; + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element[&apos;on&apos; + type] = handler; &#125; &#125;, // 移除事件 removeEvent : function(element, type, handler) &#123; if (element.removeEnentListener) &#123; element.removeEnentListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(&apos;on&apos; + type, handler); &#125; else &#123; element[&apos;on&apos; + type] = null; &#125; &#125;, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault : function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 获取事件目标 getTarget : function(event) &#123; return event.target || event.srcElement; &#125;, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent : function(e) &#123; var ev = e || window.event; if (!ev) &#123; var c = this.getEvent.caller; while (c) &#123; ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) &#123; break; &#125; c = c.caller; &#125; &#125; return ev; &#125;&#125;; Ajax 是什么？Ajax 的交互模型？同步和异步的区别？如何解决跨域问题？Ajax 是什么： 通过异步模式，提升了用户体验 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用 Ajax 在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。 Ajax 的最大的特点： Ajax可以实现动态不刷新（局部刷新） readyState 属性 状态 有5个可取值： 0 = 未初始化，1 = 启动， 2 = 发送，3 = 接收，4 = 完成 Ajax 同步和异步的区别: 同步：提交请求 -&gt; 等待服务器处理 -&gt; 处理完毕返回，这个期间客户端浏览器不能干任何事 异步：请求通过事件触发 -&gt; 服务器处理（这是浏览器仍然可以作其他事情）-&gt; 处理完毕ajax.open方法中，第3个参数是设同步或者异步。 Ajax 的缺点： Ajax 不支持浏览器 back 按钮 安全问题 Ajax 暴露了与服务器交互的细节 对搜索引擎的支持比较弱 破坏了程序的异常机制 不容易调试 解决跨域问题： jsonp iframe window.name、window.postMessage 服务器上设置代理页面 123456789101112131415161718192021222324252627282930*************************************function whatBrowser() &#123; document.Browser.Name.value=navigator.appName; document.Browser.Version.value=navigator.appVersion; document.Browser.Code.value=navigator.appCodeName; document.Browser.Agent.value=navigator.userAgent; &#125;/** 智能获取浏览器版本信息**/var browser=&#123; versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123;//移动终端浏览器版本信息 trident: u.indexOf(&apos;Trident&apos;) &gt; -1, //IE内核 presto: u.indexOf(&apos;Presto&apos;) &gt; -1, //opera内核 webKit: u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, //苹果、谷歌内核 gecko: u.indexOf(&apos;Gecko&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;KHTML&apos;) == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/)||!!u.match(/AppleWebKit/), //是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1, //android终端或者uc浏览器 iPhone: u.indexOf(&apos;iPhone&apos;) &gt; -1 || u.indexOf(&apos;Mac&apos;) &gt; -1, //是否为iPhone或者QQHD浏览器 iPad: u.indexOf(&apos;iPad&apos;) &gt; -1, //是否iPad webApp: u.indexOf(&apos;Safari&apos;) == -1 //是否web应该程序，没有头部与底部 &#125;; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase()&#125; ****状态码100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置302 Found 临时性重定向303 See Other 临时性重定向，且总是使用 GET 请求新的 URI304 Not Modified 自从上次请求后，请求的网页未修改过400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求401 Unauthorized 请求未授权403 Forbidden 禁止访问404 Not Found 找不到如何与 URI 相匹配的资源500 Internal Server Error 最常见的服务器端错误503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护） **js 操作获取和设置 cookie// 创建cookie 123456789101112131415161718192021222324252627282930313233function setCookie(name, value, expires, path, domain, secure) &#123; var cookieText = encodeURIComponent(name) + &apos;=&apos; + encodeURIComponent(value); if (expires instanceof Date) &#123; cookieText += &apos;; expires=&apos; + expires; &#125; if (path) &#123; cookieText += &quot;; path=&quot; + path &#125; if (domain) &#123; cookieText += &apos;; domain=&apos; + domain; &#125; if (secure) &#123; cookieText += &apos;; secure&apos;; &#125; document.cookie = cookieText;&#125;// 获取cookiefunction getCookie(name) &#123; var cookieName = encodeURIComponent(name) + &apos;=&apos;; var cookieStart = document.cookie.indexOf(cookieName); var cookieValue = null; if (cookieStart &gt; -1) &#123; var cookieEnd = document.cookie.indexOf(&apos;;&apos;, cookieStart); if (cookieEnd == -1) &#123; cookieEnd = document.cookie.length; &#125; cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); &#125; return cookieValue;&#125;// 删除cookiefunction unsetCookie(name) &#123; document.cookie = name + &quot;= ; expires=&quot; + new Date(0);&#125; ES6 —-模板字符串： let apple = “苹果”; let coffee = “咖啡”; let = kitChen今天的早餐是${apple} 与 ${coffee} !; function kitChen(strings, …values) { console.log(strings); // [“今天的早餐是”, “与”, “!”, raw: Array[3]] consloe.log(values); // [“苹果”, “咖啡”] } —-新字符串方法 let breakfast = “今天早餐是什么？”; console.log(breakfast.startsWith(“今天”)); // true 判断以什么开头 console.log(breakfast.endsWith(“!”)); // false 判断以什么结尾 console.log(breakfast.includes(“?”)); // true 判断是否包含 —-设置函数默认参数 function breakfast(coke = “蛋糕”, drink = “果汁”) { return ${coke} , ${drink}; } console.log(breakfast()); —-展开操作符 let fruits = [“苹果”, “香蕉”], foods = [“橘子”, …fruits]; console.log(foods); // [“橘子”, “苹果”, “香蕉”] —-函数name let breakfast = function(){} console.log(breakfast.name); // breakfast let breakfast = function superBreakfast(){} console.log(breakfast.name); // superBreakfast —-判断两个值是否相等 Object.is(NaN, NaN); // true Object.is(+0, -0); // false —-把一个对象值复制到另一个对象 let breakfast = {}; breakfast.assgin(breakfast, {drink: “啤酒”}) —-设置对象的prototype let breakfast = { getDrink(){ return “果汁”; }}; let dinner = { getDrink(){ return “啤酒”;}}; let sunday = Object.create(breakfast); // 基于breakfast创建的对象 console.log(Object.getPrototypeOf(sunday) === breakfast); // true Object.setProtytypeOf(sunday, dinner); **** console.log(Object.getPrototypeOf(sunday) === dinner); // true —- proto let breakfast = { getDrink(){ return “果汁”; }}; let dinner = { getDrink(){ return “啤酒”;}}; let sunday = { proto: breakfast }; console.log(Object.getPrototypeOf(sunday) === breakfast); // true sunday.proto = dinner; console.log(Object.getPrototypeOf(sunday) === dinner); // true —-super let breakfast = { getDrink(){ return “果汁”; }}; let dinner = { getDrink(){ return “啤酒”;}}; let sunday = { proto: breakfast, getDrink(){ return super.getDrink() + “牛奶”; } }; console.log(sunday.getDrink()); // “果汁牛奶” 问题：判断select选择情况 1234567891011121314151617$(&quot;#demo&quot;).change(function () &#123; var val = $(this).val(); var res = confirm(&quot;您确认修改为&quot;+val+&quot;么？&quot;); if(res == true)&#123; //确认 $(this).attr(&quot;hook&quot;,val); &#125;else&#123; //取消 if(typeof $(this).attr(&quot;hook&quot;) == &quot;undefined&quot;)&#123; //尚未做过选择，重置为默认选择 $(this).val($(this).children(&quot;option:first-child&quot;).val()); &#125;else&#123; //重置为修改之前的选择 $(this).val($(this).attr(&quot;hook&quot;)); &#125; &#125;&#125;); 时间format 123456789101112131415161718192021222324252627//格式化CST日期的字串function formatCSTDate(strDate, format) &#123; return formatDate(new Date(strDate), format);&#125;//格式化日期function formatDate(date, format) &#123; var paddNum = function (num) &#123; num += &quot;&quot;; return num.replace(/^(\\d)$/, &quot;0$1&quot;); &#125; //指定格式字符 var cfg = &#123; yyyy: date.getFullYear() //年 : 4位 , yy: date.getFullYear().toString().substring(2)//年 : 2位 , M: date.getMonth() + 1 //月 : 如果1位的时候不补0 , MM: paddNum(date.getMonth() + 1) //月 : 如果1位的时候补0 , d: date.getDate() //日 : 如果1位的时候不补0 , dd: paddNum(date.getDate())//日 : 如果1位的时候补0 , hh: date.getHours() //时 , mm: date.getMinutes() //分 , ss: date.getSeconds() //秒 &#125; format || (format = &quot;yyyy-MM-dd hh:mm:ss&quot;); return format.replace(/([a-z])(\\1)*/ig, function (m) &#123; return cfg[m]; &#125;);&#125;","tags":[{"name":"js","slug":"js","permalink":"https://qspinach.github.io/blog/tags/js/"}]},{"title":"npm or yarn","date":"2020-08-23T15:45:11.793Z","path":"2020/08/23/npm or yarn/","text":"centos7 下安装nodejs123456$ curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash$ curl --silent --location https://deb.nodesource.com/setup_8.x | sudo bash$ curl --silent --location https://deb.nodesource.com/setup_10.x | sudo bash$ yum install -y nodejs nvm 安装node根据提示设置nvm路径和nodejs路径node下载源 1nvm node_mirror https://npm.taobao.org/mirrors/node/ npm下载源 1nvm npm_mirror https://npm.taobao.org/mirrors/npm/ 使用nvm下载node1234567891011121314151617181920nvm install 8.0.0 64-bitnvm use 8.0.0nvm list //查看以己经安装的windows下的nvm命令nvm arch 查看当前系统的位数和当前nodejs的位数nvm install &lt;version&gt; [arch] 安装制定版本的node 并且可以指定平台 version 版本号 arch 平台nvm list [available] - nvm list 查看已经安装的版本 - nvm list installed 查看已经安装的版本 - nvm list available 查看网络可以安装的版本nvm on 打开nodejs版本控制nvm off 关闭nodejs版本控制nvm proxy [url] 查看和设置代理nvm node_mirror [url] 设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://nodejs.org/dist/nvm npm_mirror [url] 设置或者查看setting.txt中的npm_mirror,如果不设置的话默认的是：https://github.com/npm/npm/archive/.nvm uninstall &lt;version&gt; 卸载制定的版本nvm use [version] [arch] 切换制定的node版本和位数nvm root [path] 设置和查看root路径nvm version 查看当前的版本 NPM设置淘宝镜像 查询当前配置的镜像 1npm get registry https://registry.npmjs.org/ 设置成淘宝镜像 1npm config set registry http://registry.npm.taobao.org/ 换成原来的 1npm config set registry https://registry.npmjs.org/ Yarn 设置淘宝镜像 查询当前配置的镜像 1yarn config get registry https://registry.yarnpkg.com 设置成淘宝镜像 1yarn config set registry http://registry.npm.taobao.org/ 发布自己的包 注册npm账号 登录npm账号npm login 找到需要发布的包根目录下 发布包npm publish 直接发布 删除已发布的包npm unpublish 包名 --force只能删除72小时内发布的包。删除的包，在24小时内不允许重复发布。发布包需谨慎，不要发布无意义的包。 解决的一些问题 @vue/cli 创建项目是安装chromedriver时失败的问题此方法是单独安装chromdriver1npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver 所以可以在给npm和yarn设置chromedriver源设置1npm config set chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver 设置1yarn config set &quot;chromedriver_cdnurl&quot; &quot;https://npm.taobao.org/mirrors/chromedriver&quot; The engine “node” is incompatible with this module. Expected version “=&gt; ^4.0.0”.error Found incompatible module12345yarn help | grep -- --ignore --ignore-scripts don&apos;t run lifecycle scripts --ignore-platform ignore platform checks --ignore-engines ignore engines check --ignore-optional ignore optional dependencies 关于node-sass不能安装问题设置npm or yarn淘宝镜像源1npm config set sass-binary-site http://npm.taobao.org/mirrors/node-sass 指定node-sass下载源1yarn config set sass-binary-site http://npm.taobao.org/mirrors/node-sass 管理员身份运行cmd 安装 1npm install -global -production windows-build-tools","tags":[{"name":"npm","slug":"npm","permalink":"https://qspinach.github.io/blog/tags/npm/"},{"name":"yarn","slug":"yarn","permalink":"https://qspinach.github.io/blog/tags/yarn/"}]},{"title":"mysql","date":"2020-08-23T15:45:11.793Z","path":"2020/08/23/mysql/","text":"—–设置默认值若本身存在默认值，则先删除alter table表名alter column字段名drop default;然后设置默认值（若本身不存在则可以直接设定）alter table表名 alter column字段名 set default默认值; ——设置数据库导入文件最大容量set global max_allowed_packet = 210241024*10;show VARIABLES like ‘%max_allowed_packet%’; ——查看编码 修改编码show VARIABLES like ‘%char%’ [mysqld]character_set_server=utf8 ——MySql “Row size too large (&gt; 8126)”解决办法在my.ini中加入[mysqld]innodb_log_file_size = 512Minnodb_strict_mode = 0 ———————Redisredis-cli.exe127.0.0.1:6379&gt;shutdownnot connected&gt;exit 启动命令redis-server redis.windows.conf设置服务命令redis-server –service-install redis.windows-service.conf –loglevel verbose 卸载服务：redis-server –service-uninstall启动服务redis-server –service-start停止服务redis-server –service-stop mysql更改root密码#1.停止mysql数据库/etc/init.d/mysqld stop #2.执行如下命令mysqld_safe –user=mysql –skip-grant-tables –skip-networking &amp; #3.使用root登录mysql数据库mysql -u root mysql #4.更新root密码mysql&gt; UPDATE user SET Password=PASSWORD(‘xxx123’) where USER=’root’;#最新版MySQL请采用如下SQL：mysql&gt; UPDATE user SET authentication_string=PASSWORD(‘xxx123’) where USER=’root’; #5.刷新权限mysql&gt; FLUSH PRIVILEGES; #6.退出mysqlmysql&gt; quit #7.重启mysql/etc/init.d/mysqld restart #8.使用root用户重新登录mysqlmysql -uroot -pEnter password: &lt;输入新设的密码newpassword&gt;","tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://qspinach.github.io/blog/tags/Mysql/"}]},{"title":"docker","date":"2020-08-23T15:45:11.790Z","path":"2020/08/23/docker/","text":"docker安装1234567891011121314$ sudo yum remove docker \\docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2$ sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo$ sudo yum makecache fast$ sudo yum -y install docker-ce$ sudo systemctl start docker Dockerfile123456FROM docker-registry.xxx/docker/nginx:1.13.6COPY ./dist /var/www/htmlCOPY ./custom.conf /etc/nginx/conf.d/ RUN rm /etc/nginx/conf.d/default.confEXPOSE 80CMD [\"nginx\",\"-g\",\"daemon off;\"] build镜像1docker build -t 镜像名 . 运行容器将容器中的8000端口映射到服务器80端口 1docker run -it --name 容器名 -p 8000:80 镜像id 查看日志12345docker logs -f -t --since=“2017-05-31” --tail=10 容器–since : 此参数指定了输出日志开始日期，即只输出指定日期之后的日志。-f : 查看实时日志-t : 查看日志产生的日期-tail=10 : 查看最后的10条日志。 几个命令1234567891011docker start/stop/restart 容器id #启动暂停重启docker rm 容器id #删除docker kill 容器id #杀掉一个运行中的容器。docker pause/unpause 容器id #暂停/取消暂停docker create 镜像 // 创建容器但是不运行docker exec -i -t 容器 /bin/bash #开启一个交互模式的终端docker rmi &lt;image id&gt; # 移除镜像docker rmi $(docker images | grep \"none\" | awk '&#123;print $3&#125;') #移除为none的镜像docker rm $(docker ps -a | grep \"Exited\" | awk '&#123;print $1 &#125;') #移除为exited的容器docker images -a 查看镜像docker ps -a 查看容器","tags":[{"name":"Docker","slug":"Docker","permalink":"https://qspinach.github.io/blog/tags/Docker/"}]},{"title":"git","date":"2020-08-23T15:45:11.790Z","path":"2020/08/23/git/","text":"git命令git init 初始化git status 状况git add .添加git rm -r –cached 要忽略的文件git commit 将本地的变化提交到本地仓库文件夹 归档git commit –amend -m [message]使用一次新的commit，替代上一次提交 如果代码没有任何新变化，则用来改写上一次commit的提交信息git diff 可以用于对比当前状态和版本库中状态的变化git log 可以查看提交日志git reset –hard 版本 回归到指定版本git push origin HEAD –force 执行完回滚版本后，在执行这个可以删除回滚版本之后的commitgit clone + git地址 git checkout -b dev origin/dev git stash // 保存当前工作进度，会把暂存区和工作区的改动保存起来git stash save ‘message…’ // 可以添加一些注释git stash list // 显示保存进度的列表。git stash drop [stash_id] // 删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度。git stash clear // 删除所有存储的进度。 git提交顺序123456789git init 初始化git status 状况git add .添加git commit -m &apos;名称&apos;将本地的变化提交到本地仓库文件夹 归档git remote rm origin // 删除远程仓库地址git remote add origin https://github.com/QSpinach/git-demo.git // 添加远程仓库地址git remote set-url origin https://github.com/QSpinach/git-demo.git // 更改远程仓库地址git push -u origin master // 强制pushgit pull origin master 把GitHub上的项目取下来 站点1、git branch gh-pages 2、git checkout gh-pages 选择分支 3、git push -u origin gh-pages访问网址：qspinach.github.io/ + 项目名 合并项目：git merge syq-dev一、 1、从另一个版本中取回 git pull + 路径 （master）二、 1、分享版本库 git clone –bare ** git push –set-upstream origin syq-dev 本地新建的syq-dev分支，提交需要与远程分支关联 2、push到bare版本库中 git push + 版本库路径 master 3、pull取回 git pull + 版本库路径 master git clone -b 克隆指定分支 git 配置git config –global user.name “xxxx” 设置用户名 git config –global user.email “xxxx” 设置邮箱 git config user.name 查看用户名 git config user.email 查看邮箱 git config –global user.name “xxxx” 修改用户名 git config –global user.email “xxxx@xxx.com“ 修改邮箱 git一些问题git push 报错error: src refspec master does not match any.原因是本地仓库为空解决办法是本地commit以下再提交 git 这个分支bug没改完切换到其他分支改bug，再切会来继续改bug 1、执行 $ git stash 命令，将当前分支修改的内容 stash 起来2、执行 $ git stash list 命令，查看 stash 列表，会看到已经刚才的修改已存储3、执行 $ git status 命令，显示没有东西需要提交，这个时候你就可以切换到其他分支了4、执行 $ git branch | $ git checkout 切换分支5、修复完紧急的 Bug 后，就可以切回之前的分支，进行未完成的内容6、执行 $ git stash list 命令，查看 stash 列表7、执行 $ git stash apply stash@{0} 命令，恢复 id 为 4240c0c 的 stash 的内容8、执行 $ git stash drop stash@{0} 命令，删除 stash 列表中已经恢复的 id 为 4240c0c 的 stash 记录 正常clone方式git clone &lt;远程仓库地址&gt; 默认clone的是远程仓库的master分支 clone指定分支git clone -b &lt;分支名&gt; &lt;远程仓库名&gt; 在本地创建该分支的文件夹，且只包含该远程仓库的该分支下所有文件，其他分支文件不会包含 拉代码之前先输入这个命令git config –global credential.helper store","tags":[{"name":"Git","slug":"Git","permalink":"https://qspinach.github.io/blog/tags/Git/"}]},{"title":"css总结","date":"2020-08-23T15:45:11.789Z","path":"2020/08/23/css总结/","text":"浮动牛客：(1)、父级div定义 height原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。优点：简单、代码少、容易掌握缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题建议：不推荐使用，只建议高度固定的布局时使用(2)、结尾处加空div标签 clear:both原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度优点：简单、代码少、浏览器支持好、不容易出现怪问题缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法(3)、父级div定义 伪类:after 和 zoom原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。建议：推荐使用，建议定义公共类，以减少CSS代码。(4)、父级div定义 overflow:hidden原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度优点：简单、代码少、浏览器支持好缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。(5)、父级div定义 overflow:auto原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度优点：简单、代码少、浏览器支持好缺点：内部宽高超过父级div时，会出现滚动条。建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。 传智：1） 加高法2) clear:both;3) 隔墙法 &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;cl h10&quot;&gt;&lt;/div&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;4） 内墙法 &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;div class=&quot;cl h10&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;5） overflow:hidden; IE6兼容浮动IE6留了一个后门，就是只要给css属性之前，加上下划线，这个属性就是IE6认识的专有属性。 _background-color: green;第二，IE6不支持用overflow:hidden;来清除浮动的解决办法，以毒攻毒。追加一条 _zoom:1; margin1、塌陷问题2、对其方式必须有width 才能使用margin：0 auto;3、善于使用父亲的padding，而不是儿子的margin4、关于margin的IE6兼容问题 当出现连续浮动的元素，携带和浮动方向相同的margin时，队首的元素，会双倍marign。 解决方案：1、设置与浮动相反的margin 2、给首元素加：_margin-left 超链接1、记住，这四种状态，在css中，必须按照固定的顺序写：a:link 、a:visited 、a:hover 、a:active2、所有的a不继承text、font这些东西。因为a自己有一个伪类的权重。 background1、背景是否固定。background-attachment:fixed; position1、绝对定位的儿子，无视参考的那个盒子的padding。2、不一定是相对定位，任何定位，都可以作为参考点3、绝对定位的盒子居中 margin:0 auto;失效。 left:50%; margin-left:负的宽度的一半。4、固定定位 IE6不兼容。 z-index1、只有定位了的元素，才能有z-index值。也就是说，不管相对定位、绝对定位、固定定位，都可以使用z-index值。 而浮动的东西不能用。2、从父现象：父亲怂了，儿子再牛逼也没用。 常见的浏览器兼容性解决方案(1)浏览器兼容问题一：不同浏览器的标签默认的外补丁和内补丁不同问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。碰到频率:100%解决方案：CSS里 {margin:0;padding:0;}备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符来设置各个标签的内外补丁是0。(2)浏览器兼容问题二：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大问题症状:常见症状是IE6中后面的一块被顶到下一行碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性备注：我们最常用的就是div+CSS布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。(3)浏览器兼容问题三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度碰到频率：60%解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。(4)浏览器兼容问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug问题症状：IE6里的间距比超过设置的间距碰到几率：20%解决方案 ： 在display:block;后面加入display:inline;display:table;备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。(5) 浏览器兼容问题五：图片默认有间距问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。碰到几率：20%解决方案：使用float属性为img布局备注 ： 因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（我的一个学生使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用）(6) 浏览器兼容问题六：标签最低高度设置min-height不兼容问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容碰到几率：5%解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}备注：在B/S系统前端开时，有很多情况下我们又这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。(7)浏览器兼容问题七：透明度的兼容CSS设置一般在ie中用的是filter:alpha(opacity=0);这个属性来设置div或者是块级元素的透明度，而在firefox中，一般就是直接使用opacity:0,对于兼容的，一般的做法就是在书写css样式的将2个都写上就行，就能实现兼容 天猫 使用的css reset重置浏览器默认样式：1@charset &quot;gb2312&quot;;body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123;margin: 0;padding: 0&#125;body, button, input, select, textarea &#123;font: 12px &quot;microsoft yahei&quot;;line-height: 1.5;-ms-overflow-style: scrollbar&#125;h1, h2, h3, h4, h5, h6 &#123;font-size: 100%&#125;ul, ol &#123;list-style: none&#125;a &#123;text-decoration: none;cursor:pointer&#125;a:hover &#123;text-decoration: underline&#125;img &#123;border: 0&#125;button, input, select, textarea &#123;font-size: 100%&#125;table &#123;border-collapse: collapse;border-spacing: 0&#125;.clear &#123;clear:both&#125;.fr &#123;float:right&#125;.fl &#123;float:left&#125;.block &#123;display:block;text-indent:-999em&#125; 网站重构网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变 UI 的情况下，对网站进行优化，在扩展的同时保持一致的 UI。 对于传统的网站来说重构通常是： 表格(table)布局改为 DIV + CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对 IE6 有效的) 对于移动平台的优化 针对于 SEO 进行优化 深层次的网站重构应该考虑的方面 减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决) 程序的性能优化(如数据读写) 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存","tags":[{"name":"css","slug":"css","permalink":"https://qspinach.github.io/blog/tags/css/"}]},{"title":"Linux总结","date":"2020-08-23T15:45:11.788Z","path":"2020/08/23/Linux总结/","text":"命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677sudo apt-get update 更新软件源cd 进入某文件夹 cd - 快速回到上传路径ls 显示目录下所有文件mkdir 创建文件夹 mkdir a/b/c/d -p 创建文件夹touch 创建文件pwd 显示当前目录地址q 退出当前（man ls ）clear 清除终端显示信息tab键 自动补全文件名cat 查看文件内容 小文件适用history 显示历史命令! + 历史命令行号 执行对应命令rm 删除文件或文件夹 rm -r 递归地删除目录下的内容 删除文件夹rmdir 只能删非空文件夹* 是通配符（ls 2* 显示以2开头文件或目录)？是通配符（ls 2? 显示以2开头的两位名文件或目录）[] 通配符 （ls 1[1-5]3.txt 显示指定范围的文件和文件夹）&gt; 重定向 （ls &gt; xxx.txt 如果有xxx.txt文件，先删除xxx.txt内容删掉，再把显示在终端的信息放到文件里面。如果没有就直接生成文件再添加内容）&gt;&gt; 重定向追加 （ls &gt;&gt; xxx.txt 把内容放到文件里面的末尾）more 查看文件内容 （f往下翻， b往回撤 ） 大文件适用| 管道 （ls -alh /bin | more）将显示的内容分页显示 通过 | 进行分流ctrl + c 终止mv 源文件名 新文件名 (重命名文件或文件夹)mv 源文件 文件夹路径 剪切并粘贴到文件路径cp 文件 文件路径 复制粘贴， cp -r 复制粘贴文件夹ln -s 对谁创建快捷方式 创建后的文件名 （软链接）ln 对谁创建快捷方式 创建后的文件名 （硬链接） 删除原文件不影响创建后的文件ls -lh 查看文件的链接数grep -n &quot;ntfs&quot; xxx.txt 在xxx.txt文件中查找ntfs， -n是显示行号，-v 显示不包含ntfs的内容:wq 保存退出 :q! 不保存退出tar -cvf test.tar *py 打包所有py文件倒test.tartar -xvf test.tar 解包tar -zcvf xxx.tar.gz *py 压缩 -C /dongge 指定路径tar -zxvf xxx.tar.gz 解压tar -jcvf yyy.tar.bz2 *py 压缩zip zzz.zip *pyunzip zzz.zip, unzip -d /test4 zzz.zip 解压到指定路径wich ls 查看命令所在的文件路径cal 打印日历 -y 2018 打印2018年日历date &quot;+%Y-%m-%d&quot; 打印时间ps -aux 显示进程top 动态显示进程top 显示进程ps -ef|grep tomcat 查找相应进程kill -9 9909 杀死进程， -9 强制杀死进程reboot 重启shutdown -h （now或10或 20:20） 关机 指定时间df -h 查看硬盘使用情况du -h 显示当前路径使用情况ifconfig 显示网络信息ping 检查是否能网络连通sudo useradd shuaige -m 创建用户cat /etc/passwd 查看有多少账户su shuaige 切换shuaige用户sudo passwd shuaige 更新密码ssh python@172.16.7.139 远程登录电脑whoami 显示当前登录用户exit 退出当前用户文件权限rwx 可读 可写 可执行 r-- 只能读r-x 可读 可执行 但是不能写chmod u=rwx 2.py 修改权限 拥有者uchmod g=rwx 2.py 修改权限 同组者gchmod o=rwx 2.py 修改权限 其他o777 vim操作————————vim————————————- 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960i 光标前插入a 光标后插入esc 退出编辑模式:wq 保存并退出o 下一行插入I 行首A 行尾O 上一行插入yy 复制光标所在一行4yy 复制光标所在的行开始向下4行p 粘贴dd 剪切 删除光标所在的行2dd 剪切 删除光标所在的行往下2行D 剪切当前行光标后的所有内容d0 剪切当前行光标前的所有内容x 删除光标后的内容X 删除光标前的内容h 左 j下 k上 l右H 当前屏幕的上方M 当前屏幕中间L 当前屏幕的下方Ctrl + f 向下翻一页Ctrl + b 向上翻一页Ctrl + d 向下翻半屏Ctrl + u 向上翻半屏2G 快速定位到第二行G 快速调到整个代码的最后一行gg 快速回到整个代码的第一行w 向后跳一个单词的长度， 即跳到下一个单词的开始处b 向前跳一个单词的长度， 即跳到上一个单词的开始处u 撤销刚刚的操作Ctrl + r 反撤销v 选择V 选择光标经过的行&gt;&gt; 向右移动代码&lt;&lt; 向左移动代码. 重复执行上一次的命令/hello 查找hellon 下一个helloN 上一个hellor 替换一个字符R 替换光标以及后边的字符:%s/abc/123/g abc全部替换为123:1, 10s/abc/123/g 第一行到第10行的abc全部替换为123shift + zz 相当于wq末行模式w 保存q 退出wq 保存并退出 ====================================================== centos安装ss1、安装应用 123yum install python-setuptoolseasy_install pippip install shadowsocks 2、配置文件 12345678910111213141516171819202122232425262728mkdir /etc/shadowsocksvim /etc/shadowsocks/ss.json// 单用户&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:9000, //服务端口 &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;123456&quot;, //服务密码 &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, //加密方式 &quot;fast_open&quot;:false, &quot;workers&quot;: 1&#125;// 多用户一定要开启防火墙端口号&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:9000, //服务端口 &quot;port_passowrd&quot;: &#123; &quot;9000&quot;:&quot;123456&quot;, &quot;9001&quot;:&quot;12345678&quot; &#125;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, //加密方式 &quot;fast_open&quot;:false,&#125; 3、运行此方法可能无效 123ssserver -c /etc/shadowsocks/ss.json -d start ssserver -c /etc/shadowsocks/ss.json -d stop //停止ssserver -c /etc/shadowsocks/ss.json -d restart //重启 推荐使用以下方式运行 12345678910111213141516171819vim /usr/lib/systemd/system/ss.service[Unit]Description=Shadowsocks ServerAfter=network.target[Service]PermissionsStartOnly=trueExecStartPre=/bin/mkdir -p /run/shadowsocksExecStartPre=/bin/chown nobody:nobody /run/shadowsocksExecStart=/usr/bin/ssserver -c /etc/shadowsocks/ss.json #之前的配置地址Restart=on-abortUser=nobodyGroup=nobodyUMask=0027[Install]WantedBy=multi-user.target运行服务并设置开机自启：systemctl start sssystemctl enable ss 4、注意防火墙需要开启端口号9000，修改过后重启防火墙才能生效systemctl start firewalld.service（开启防火墙）systemctl stop firewalld.service（停用防火墙）service firewalld restart（重启防火墙）firewall-cmd –zone=public –add-port=9000/udp –permanen(指定端口范围为9000通过防火墙)firewall-cmd –zone=public –add-port=9000/tcp –permanen(指定端口范围为9000通过防火墙)firewall-cmd –reload window使用shadowsocks1、安装shadowsocks，地址在github上搜sadowsocks-window2、配置一下服务器地址，服务器端口，密码以及加密方式（与服务器对应）3、启动系统代理，PAC模式和全局模式都可以，PAC模式一般是被代理被墙了的 // https://kiwivm.64clouds.com/main-exec.php?mode=extras_shadowsocks ====================================================== mysql 安装 123sudo apt-get install mysql-serversudo apt isntall mysql-clientsudo apt install libmysqlclient-dev 启动service mysql start 关闭service mysql stop 重启service mysql restart mysql -uroot -p syqroot 现在设置mysql允许远程访问，首先编辑文件/etc/mysql/mysql.conf.d/mysqld.cnf： sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf 注释掉bind-address = 127.0.0.1： ====================================================== 在 Ubuntu 系统安装 Redis 可以使用以下命令:$sudo apt-get update$sudo apt-get install redis-server启动 Redis$ redis-server查看 redis 是否启动？$ redis-cli以上命令将打开以下终端： redis 127.0.0.1:6379&gt;127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令。 flushall ——&gt; 清空整个 Redis 服务器的数据(删除所有数据库的所有 key ) flushdb ——&gt; 清空当前数据库中的所有 key redis 127.0.0.1:6379&gt; pingPONG以上说明我们已经成功安装了redis。 如果是用apt-get或者yum install安装的redis，可以直接通过下面的命令停止/启动/重启redis /etc/init.d/redis-server stop/etc/init.d/redis-server start/etc/init.d/redis-server restart如果是通过源码安装的redis，则可以通过redis的客户端程序redis-cli的shutdown命令来重启redis redis-cli -h 127.0.0.1 -p 6379 shutdown如果上述方式都没有成功停止redis，则可以使用终极武器 kill -9 /usr/local/redis/bin/redis-cli ===================================================== tomcat查看输出logstail -f catalina.out查看tomcat进程ps -ef | grep tomcat ==================================================腾讯云服务器+———————————————————————-| YJCOM [ EASY CLOUD EASY WEBSITE]” &gt;&gt; $README+———————————————————————-| Copyright (c) 2015 http://yjcom.com All rights reserved.+———————————————————————- nginx /usr/local/nginxtomcat6 /var/tomcat/tomcat-6tomcat7 /var/tomcat/tomcat-7tomcat8 /var/tomcat/tomcat-8mysql5.6 /var/lib/mysql ./tomcat.sh stop|start mysql: service mysql (start|stop|restart)vsftpd: service vsftpfd (start|stop|restart)nginx: service nginx (start|stop|restart) www ftp directory /yjdata/www/www/ change tomcat version for the default site/yjdata/www/www/change_tomcat_version.sh 6|7|8 change jdk version for the default site/yjdata/www/www/change_jdk_version.sh 1.6|1.7|1.8 ====================================================================== netstat -ntlp //查看当前所有tcp端口· netstat -ntulp |grep 80 //查看所有80端口使用情况· netstat -an | grep 3306 //查看所有3306端口使用情况· sftp登录 1sftp -P [port] [user]@[ip] get 取得远程服务器上的指定文件 put 上传本地指定的文件到远程服务器上 put -r 上传本地指定的文件夹到远程服务器上 示例: get -r ./* /Users/voidcc.com/本地项目目录/ 从远程下载所有文件及文件夹到本地项目目录 日志查看查看nginx日志导出指定日期到指定文件sed -n ‘/5/Jan/2021/,/6/Jan/2021/p’ access.log&gt;20210105.log sed 参数简介：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。123456789101112131415-e ：直接在命令列模式上进行 sed 的动作编辑；-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)-i ：直接修改读取的文件内容，而不是输出到终端。动作说明： [n1[,n2]]functionn1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』function：a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！ 正则元字符^ 行首定位符 /^my/ 匹配所有以my开头的行$ 行尾定位符 /my$/ 匹配所有以my结尾的行. 匹配除换行符以外的单个字符 /m..y/ 匹配包含字母m，后跟两个任意字符，再跟字母y的行匹配零个或多个前导字符 /my*/ 匹配包含字母m,后跟零个或多个y字母的行[] 匹配指定字符组内的任一字符 /[Mm]y/ 匹配包含My或my的行[^] 匹配不在指定字符组内的任一字符 /[^Mm]y/ 匹配包含y，但y之前的那个字符不是M或m的行(..) 保存已匹配的字符 1,20s/(you)self/\\1r/ 标记元字符之间的模式，并将其保存为标签1，之后可以使用\\1来引用它&amp; 保存查找串以便在替换串中引用 s/my/&amp;/ 符号&amp;代表查找串。my将被替换为my&lt; 词首定位符 /&lt;my/ 匹配包含以my开头的单词的行 词尾定位符 /my&gt;/ 匹配包含以my结尾的单词的行x{m} 连续m个x /9{5}/ 匹配包含连续5个9的行x{m,} 至少m个x /9{5,}/ 匹配包含至少连续5个9的行x{m,n} 至少m个，但不超过n个x /9{5,7}/ 匹配包含连续5到7个9的行","tags":[{"name":"Linux","slug":"Linux","permalink":"https://qspinach.github.io/blog/tags/Linux/"}]},{"title":"React学习","date":"2020-08-23T15:45:11.788Z","path":"2020/08/23/React学习/","text":"React学习 React环境基础搭建与安装 nodejs下载与安装 安装完成后执行如下指令，确定安装成功 1node -v 1npm -v 快速新建react项目 全局安装create-react-app, 命令行依次输入以下命令，完成react项目的搭建 1234npm install -g create-react-appcreate-react-app my-react-appcd my-react-appnpm start 浏览器输入localhost:3000，即可运行。 ​ ES6语法巩固（待完成） let &amp; const let声明变量，用法类似于var，只是声明的变量只在let命令所在代码块内有效。 1234for (let i = 0; i&lt; 10; i++) &#123; // ...&#125;console.log(i) // 报错 const声明一个只读的常量，一旦声明了，就不能改变。只能在声明的位置后面使用，且不能重复声明。 12const PI = 3.1314;PI = 3 // 错误 变量的解构赋值 2.1 数组的解构赋值 12345678let [a, b, c] = [1, 2, 3] // 从数组中提取值，按照对应位置，对变量赋值let [foo] = []; // 变量解构不成功 foo 等于 undefinedlet [x = true] = []; // 设置x的默认值为truelet [y = 1] = [null]; // y值为null。 只有当一个数组成员严格等于undefined，默认值才会生效。即null !== undefinedlet [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4] 2.2对象的解构赋值 变量必须与属性同名，才能取到正确的值，与位置无关。 123let &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;; // foo值为\"aaa\", bar值为\"bbb\"let &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;; // foo值为\"aaa\", bar值为\"bbb\"let &#123; x = 3 &#125; = &#123;&#125;; // 指定默认值 如果变量名与属性名不一致 1let &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;; // baz值为\"aaa\" 2.3 字符串的解构赋值 12345678const [a, b, c, d, e] = 'hello';a // \"h\"b // \"e\"c // \"l\"d // \"l\"e // \"o\"let &#123; length: len &#125; = 'hello'; // len值为5 2.4 函数的解构赋值 函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 12345678910111213141516function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3// map遍历[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b); // [3, 7]// 使用默认值function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 解构使用情况是，大多是对JSON数据的提取，加载模块时，指定需加载模块的方法。 字符串的扩展 includes() 表示是否找到了参数字符串 startsWith() 表示参数字符串是否在原字符串的头部。 endsWith() 表示参数字符串是否在原字符串的尾部 使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 12345678let s = 'Hello world!';s.startsWith('Hello'); // trues.endsWith('!'); // trues.includes('o'); // trues.startsWith('wrold', 6); // trues.endsWith('Hello', 5); // trues.includes('Hello', 6); // false padStart(), padEnd() 如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 123456'1'.padStart(10, '0') // \"0000000001\"'12'.padStart(10, '0') // \"0000000012\"'123456'.padStart(10, '0') // \"0000123456\"'12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\"'09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\" 模板字符串 模板字符串是增强版的字符串，用 (`)标识。可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 12345`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// \"1 + 2 = 3\"`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// \"1 + 4 = 5\" 数值的扩展 Number.isFinite(), Number.isNaN() Number.isFinite()用来检查一个数值是否为有限的。 Number.isNaN()用来检查一个值是否为NaN。 12345678910111213141516Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite('foo'); // falseNumber.isFinite('15'); // falseNumber.isFinite(true); // falseNumber.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN('15') // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN('true' / 0) // trueNumber.isNaN('true' / 'true') // true Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。 Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。 123456789101112131415Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1// trueNumber.MAX_SAFE_INTEGER === 9007199254740991// trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER// trueNumber.MIN_SAFE_INTEGER === -9007199254740991// trueNumber.isSafeInteger('a') // falseNumber.isSafeInteger(null) // falseNumber.isSafeInteger(3) // trueNumber.isSafeInteger(1.2) // falseNumber.isSafeInteger(9007199254740990) // trueNumber.isSafeInteger(9007199254740992) // false Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。 12345Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaN Math.cbrt方法用于计算一个数的立方根。 ​ React基本用法JSX在编译之后呢，JSX 其实会被转化为普通的 JavaScript 对象。 12345const element = ( &lt;h1 className=\"greeting\"&gt; Hello, world! &lt;/h1&gt;); 12345const element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, world!'); 上面两种写法相同 元素渲染要将React元素渲染到根DOM节点中，我们通过把它们都传递给 ReactDOM.render() 的方法来将其渲染到页面上。在实际生产开发中，大多数React应用只会调用一次 ReactDOM.render() 。 12345678910111213141516171819function formatName(user) &#123; return user.firstName + ' ' + user.lastName;&#125;const user = &#123; firstName: 'Harper', lastName: 'Perez'&#125;;const element = ( &lt;h1&gt; Hello, &#123;formatName(user)&#125;! &lt;/h1&gt;);ReactDOM.render( element, document.getElementById('root')); React DOM 会比较元素内容先后的不同，在渲染过程中只会更新改变了的部分。 组件与Props组件的定义分为函数定义和类定义，这两种组件在React中是相同的，使用类就允许我们使用其它特性，例如局部状态、生命周期钩子。 函数定义是最简单的定义方式： 123function Demo (props) &#123; return &lt;h1&gt;Hello, &#123; props.name &#125;&lt;/h1&gt;&#125; 使用class定义组件: 12345class Demo extends React.Component &#123; render () &#123; return (&lt;h1&gt;hello, &#123; this.props.name &#125;&lt;/h1&gt;); &#125;&#125; 组件可以引用其它组件，即可以抽象一些层次细节，如按钮，表单，对话框。 12345678910111213function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;function App() &#123; return ( &lt;div&gt; &lt;Welcome name=\"Sara\" /&gt; &lt;Welcome name=\"Cahal\" /&gt; &lt;Welcome name=\"Edite\" /&gt; &lt;/div&gt; );&#125; 当UI中有一部分重复使用过了好多次，或者本身足够复杂，都是可以抽象出一个可复用的组件。 12345678910function UserInfo(props) &#123; return ( &lt;div className=\"UserInfo\"&gt; &lt;Avatar user=&#123;props.user&#125; /&gt; &lt;div className=\"UserInfo-name\"&gt; &#123;props.user.name&#125; &lt;/div&gt; &lt;/div&gt; );&#125; Props的只读性，一个组件的props是不能被自己修改的，所有的React组件都必须像纯函数使用props 123function sum (a, b) &#123; return a + b;&#125; state状态与属性十分相似，但是状态是私有的，完全受控于当前组件。 123456789101112131415class Clock extends React.Component &#123; constructor (props) &#123; super(props); this.state = &#123; date: new Date() &#125; &#125; render () &#123; return ( &lt;div&gt; &lt;h1&gt;time: &#123;this.state.date.toLocaleTimeString()&#125;&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125; 更改state方法 123this.setState(&#123; date: new Date()&#125;) State 的更新是异步的,调用setState 组件的state并不会立即改变。 12345678910state = &#123; quantity: 0&#125;add = () =&gt; &#123; this.setState((preState, props) =&gt; &#123; console.log(preState.quantity); // preState先前的状态, props当前最新的属性props return &#123; quantity: preState.quantity + 1 &#125; &#125;); console.log(this.state.quantity) // 0&#125; 当调用setState修改组件状态时，只需要传入发生改变的State，而不是组件完整的State，因为组件State的更新是一个浅合并的过程。 1234567state = &#123; a: 1, b: 2&#125;this.setState(&#123; a: 3&#125;); 生命周期 react周期图 Mounting：已插入真实DOM constructor() 在组件的实例创建时调用，可以初始化state。 componentWillMount() 在组件渲染之前调用，在这里可以修改state不会触发重新渲染。 render() 渲染组件，检查this.state和this.props返回react元素，也可以返回null或false，只能有一个顶级组件，不能改变组件的状态。组件首次加载，组件内部state改变，组件接收到新的props时都会触发render渲染，并且只会渲染改变了的节点。 componentDidMount() 组件渲染完成后调用，在这里初始化DOM节点，可以进行网络请求拉取远端数据。修改state会触发组件的重新渲染。 Updating：正在被重新渲染 props和state的改变会让组件重新渲染 componentWillReceiveProps(nextProps) 组件接收到新的props时调用，新的props作为其参数nextProps使用，在这里可以更改组件的props和state。 shouldComponentUpdate(nextProps, nextState) 组件是否渲染新的props或state，返回false表示跳过后续componentWillUpdate，render，componentDidUpdate方法。在组件的首次渲染和使用forceUpdate()时不会调用此方法。通常不怎么使用此方法。 componentWillUpdate(nextProps, nextState) 在接收到新的props或者state后，进行渲染之前调用，此方法中不允许更新state或props，此时可以修改state。组件初次渲染不调用此方法。 componentDidUpdate() 完成渲染新的props或state后调用，可在这里操作新的DOM元素。 Unmounting：已移除真实DOM componentWillUnmount() 组件被移除之前调用，在这里执行清理操作，如清除定时器，监听器。 其他：通过extends React.Conponent给组件初始化不会执行getDefaultProps和getInitialState。 12345678910111213141516class Demo extends React.Component &#123; // 初始化props static defaultProps = &#123; onClick: null, className: '', text: '默认' &#125; // 初始化state constructor (props) &#123; super(props); this.state = &#123; time: 0, log: [] &#125; &#125;&#125; 调用 forceUpdate() 会导致组件跳过 shouldComponentUpdate() ，直接调用 render()。 处理事件当使用一个ES6定义一个组件时，通常的一个事件处理程序是类上的一个方法。 12345678910111213141516class Toggle extends React.Component &#123; constructor (props) &#123; super(props); this.handleClick = this.handleClick.bind(this); &#125; handleClick () &#123; console.log(\"handleClick\"); &#125; render () &#123; return ( &lt;div&gt; &lt;button onClick=\"this.handleClick\"&gt;&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 不调用bind(this),使用属性初始化语法。 123456789101112class Toggle extends React.Component &#123; handleClick = () =&gt; &#123; console.log(\"handleClick\"); &#125; render () &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 不使用属性初始化语法 123456789101112class Toggle extends React.Component &#123; handleClick () &#123; console.log(\"handleClick\"); &#125; render () &#123; return ( &lt;div&gt; &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt;&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 传递参数给事件处理 12&lt;button onClick=&#123;(e) =&gt; this.handleClick(id, e)&#125;&gt;BTN&lt;/button&gt;&lt;button onClick=&#123;this.handleClick.bind(this,id)&#125;&gt;BTN&lt;/button&gt; React进阶组件及其交互通信父组件向子组件传值，通过 props 属性传递，在父组件给子组件设置 props，然后子组件就可以通过 props 访问到父组件的数据或者方法，这样就搭建起了父子组件间通信的桥梁。 12345678910111213141516171819class Parents extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; dataList: [], name: 'parents' &#125; &#125; logChildName = (cname) =&gt; &#123; console.log(cname); &#125; render () &#123; return ( &lt;div&gt; &lt;Child alertHandler=&#123;this.logChildName&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 子组件通过父组件传递的方法来传递值。 123456789101112131415161718class Child extends React.Component &#123; constructor(props)&#123; super(props); this.state = &#123; name: 'Child' &#125; &#125; handleClick = () =&gt; &#123; this.props.alertHandler(this.state.name); &#125; render()&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;show child name&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 网络通信在react项目中获取数据的工具比较多，比如fetch axios 。一般获取网络请求数据是在componentDidMount()中操作，然后通过promise获取数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import axios from 'axios';import React from 'react';import Tableconst urlString = 'http://localhost:3000/';export default class TestAxios extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; tableData: [] &#125; &#125; // get获取数据 getTableData () &#123; axios.get(urlString,&#123; headers: &#123;&#125;, // 设置响应头 params: &#123; page: 1, limit: 10 &#125; &#125;) .then((res) =&gt; &#123; // 得到值 return res.data; &#125;) .then((data) =&gt; &#123; // 进行处理 this.setState(&#123; tableData: data &#125;) &#125;) .catch((error) =&gt; &#123; // 错误处理 console.log(error); &#125;) &#125; componentDidMount()&#123; this.getTableData(); &#125; render () &#123; return ( &lt;div&gt; &#123; /* Table 用于展示tableData */ &#125; &lt;Table data=&#123;this.state.tableData&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 发送post请求，通过promise处理返回数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import axios from 'axios';import React from 'react';const urlString = 'http://localhost:3000/';export default class TestPostAxios extends React.Component &#123; constructor (props) &#123; super(props); this.state = &#123; vaule: '' &#125; &#125; // 更改input的value handleChange = (event) =&gt; &#123; this.setState(&#123; value: event.target.value &#125;); &#125; // 提交操作 handleSubmit = (event) =&gt; &#123; console.log('submit value ' + this.state.value); &#125; // post请求 addName = (name) =&gt; &#123; axios.post(urlString, &#123; name, &#125;, &#123; headers: &#123;&#125; &#125;) .then((res) =&gt; &#123; console.log(res.data); &#125;) .catch((error) =&gt; &#123; consoloe.log(error); &#125;) &#125; render () &#123; return ( &lt;div&gt; &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; name: &lt;input type=\"text\" value=\"this.state.value\" onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;/form&gt; &lt;/div&gt; ); &#125;&#125; 一个项目中get或post请求中的地址主机和端口基本不变，也可以自己再讲axios封装一次，让网络请求业务和react的视图分开方便管理。 Refs用法控制一些DOM原生的效果，如输入框的聚焦效果和选中效果等；触发一些命令式的动画；集成第三方的DOM库。如果要实现的功能可以通过声明式的方式实现，就不要借助Ref。 如果作用在原生的DOM元素上，通过Ref获取的是DOM元素，可以直接操作DOM的API。 123456789101112131415161718192021222324252627class CustomTextInput extends React.Component &#123; constructor(props) &#123; super(props); this.focusTextInput = this.focusTextInput.bind(this); &#125; focusTextInput() &#123; // 获取DOM元素后可以直接操作DOM API this.textInput.focus(); &#125; render() &#123; // 通过Ref获取DOM元素，再保存在实例变量focusTextInput中 return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt; &lt;input type=\"button\" value=\"Focus the text input\" onClick=&#123;this.focusTextInput&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 在子节点上暴露一个特殊的属性，子节点将会获得一个函数属性，并将其作为 ref 属性附加到 DOM 节点。 1234567891011121314151617function CustomTextInput(props) &#123; return ( &lt;div&gt; &lt;input ref=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;class Parent extends React.Component &#123; render() &#123; return ( &lt;CustomTextInput inputRef=&#123;el =&gt; this.inputElement = el&#125; /&gt; ); &#125;&#125; 深入JSX 组件定义必须以大写字母开头 不能使用一个普通的表达式作为 React 元素的标签。 jsx中的props属性可以是JavaScript表达式，字符串字面量。 属性默认值为true。 属性扩展 1234function App () &#123; const props = &#123;firstName: 'Ben', lastName: 'Hector'&#125;; return &lt;Greeting &#123;...props&#125; /&gt;; &#125; JSX中的Children可以是字符串字面量，多个JSX元素，JavaScript表达式，回调函数。Booleans、Null、Undefined会被忽略。 React Router安装react router通过npm安装，命令行输入： 1npm install --save react-router-dom 基本使用引入react-router-dom，设置项目的router 如下，当输入地址为/ 页面输出为App组件页面，当地址为/about/id 页面输出为About组件页面，当地址输入为/topics 页面输出为Topics组件页面。 12345678910111213141516171819202122import &#123; BrowserRouter as Router, Route, Link, Switch &#125; from 'react-router-dom';import ReactDOM from 'react-dom';import React from 'react';import App from './../pages/App';import About from './../pages/About';import Topics from './../pages/Topics';class RouterApp extends React.Component &#123; render ()&#123; return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route path='/' component=&#123;App&#125; /&gt; &lt;Route path=\"/about/:id\" component=&#123;About&#125;/&gt; &lt;Route path=\"/topics\" component=&#123;Topics&#125;/&gt; &lt;/Switch&gt; &lt;/Router&gt; ); &#125;&#125;ReactDOM.render(&lt;RouterApp /&gt;, document.getElementById('root')); 获取地址URL参数，通过this.props.match可以获取url参数，params参数。如果地址输入/about/123 。通过params也可以完成页面之间的传值。 123const &#123; url, params &#125; = this.props.match;console.log(url); // /about/123console.log(params); // &#123;id: 123&#125; 当路径未匹配path时应当有404界面。 1&lt;Route component=&#123;NoMatch&#125; /&gt; 当组件中需要用到跳转时需使用Link 其中的传递的参数可以在props 的location 中获取。 1234567891011121314import &#123;Link&#125; from 'react-router-dom';export default class RouterTest extends React.Component &#123; render () &#123; return ( &lt;Link to=&#123;&#123; pathname: '/index', search: '?sort=name', hash: '#the-hash', state: &#123; fromDashboard: true &#125; &#125;&#125; &gt;跳转to&lt;/Link&gt; ); &#125;&#125; 也可以通过函数传值。 1234567891011121314// 向详情页传递要传递的值clickHandler(value) &#123; browserHistory.push(&#123; pathname: '/detail/' + value, query: &#123; billName: value.brandNm, billTittle: value.ticketNm, billImg: value.billPicPath, billId: value.billId &#125;, &#125;) console.log(value); &#125;&#125; 当然如果需要重定向到新的一个地址就可以用Redirect 来实现。 123456789import &#123; Route, Redirect &#125; from 'react-router'&lt;Route exact path=\"/\" render=&#123;() =&gt; ( loggedIn ? ( &lt;Redirect to=\"/dashboard\"/&gt; ) : ( &lt;PublicHomePage/&gt; ))&#125; /&gt; 传值方式同Link 一样。 12345&lt;Redirect to=&#123;&#123; pathname: '/login', search: '?utm=your+face', state: &#123; referrer: currentLocation &#125;&#125;&#125;/&gt; 其他v3与v4https://www.jianshu.com/p/bf6b45ce5bcc https://blog.csdn.net/sinat_17775997/article/details/69218382 Webpack安装本地安装 12npm install --save-dev webpacknpm install --save-dev webpack@&lt;version&gt; 全局安装 1npm install --gobal webpack 基本使用123456789const path = require('path');module.exports = &#123; entry: './src/index.js', // 入口文件 output: &#123; // 出口文件 filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;; 资源管理 css加载，需安装css-loader和style-loader并在module配置 1npm install --save-dev style-loader css-loader 1234567891011121314151617181920const path = require('path'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] &#125; ] &#125; &#125;; 图片加载，需安装配置file-loader 1npm install --save-dev file-loader 12345678910module: &#123; rules: [ &#123; test: /\\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ] &#125; ]&#125; 字体加载同样需要安装配置file-loader 12345678910module: &#123; rules: [ &#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ] &#125; ]&#125; 加载数据,如 JSON 文件，CSV、TSV 和 XML。使用csv-loader和xml-loader安装配置即可处理CSV、TSV 和 XML类型的文件。 1npm install --save-dev csv-loader xml-loader 12345678910111213141516module: &#123; rules: [ &#123; test: /\\.(csv|tsv)$/, use: [ 'csv-loader' ] &#125;, &#123; test: /\\.xml$/, use: [ 'xml-loader' ] &#125; ]&#125; HtmlWebpackPlugin 创建了一个全新的文件，所有的 bundle 会自动添加到 html 中。 123456789101112131415161718const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/index.js', print: './src/print.js' &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: 'Output Management' &#125;) ], output: &#123; filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; HtmlWebpackPlugin 在每次构建前清理 /dist 文件夹 1234567891011121314151617181920const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/index.js', print: './src/print.js' &#125;, plugins: [ new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin(&#123; title: 'Output Management' &#125;) ], output: &#123; filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; 为了更容易跟踪错误和警告JavaScript 提供了 source map 功能。 123module.exports = &#123; devtool: 'inline-source-map',&#125; webpack-dev-server 提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)。 123456// webpack.jsmodule.exports = &#123; devServer: &#123; contentBase: './dist' &#125;,&#125; 1234// package.json\"scripts\": &#123; \"server\": \"webpack-dev-server --open\"&#125; 模块热替换是webpack内置的功能，无需进行完全刷新。 12345678910// webpack.jsmodule.exports = &#123; devServer: &#123; contentBase: './dist', hot: true &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125; tree shaking移除 JavaScript 上下文中的未引用代码(dead-code)。从 webpack 4 开始，也可以通过 &quot;mode&quot; 配置选项轻松切换到压缩输出，只需设置为 &quot;production&quot;。 123module.exports = &#123; mode: \"production\"&#125; 高阶拓展ReduxMobxDva","tags":[{"name":"React","slug":"React","permalink":"https://qspinach.github.io/blog/tags/React/"}]},{"title":"随拍图片","date":"2019-10-23T03:30:21.000Z","path":"2019/10/23/picture/","text":"转载图片请说明出处 图片1","tags":[{"name":"picture","slug":"picture","permalink":"https://qspinach.github.io/blog/tags/picture/"}]}]